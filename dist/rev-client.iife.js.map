{"version":3,"sources":["../src/index.ts","../src/utils/is-utils.ts","../src/interop/index.ts","../src/utils/rate-limit.ts","../src/utils/index.ts","../src/rev-error.ts","../src/utils/paged-request.ts","../src/utils/request-utils.ts","../src/api/admin.ts","../src/utils/parse-csv.ts","../src/api/audit-request.ts","../src/api/audit.ts","../src/api/oauth.ts","../src/api/auth.ts","../src/api/category.ts","../src/api/channel.ts","../src/api/device.ts","../src/api/group.ts","../src/api/playlist.ts","../src/api/recording.ts","../src/utils/file-utils.ts","../src/api/upload.ts","../src/api/user.ts","../src/api/video-report-request.ts","../src/api/video-download.ts","../src/api/video.ts","../src/api/webcast-report-request.ts","../src/api/webcast.ts","../src/api/zones.ts","../src/rev-session.ts","../src/rev-client.ts"],"sourcesContent":["export * from './rev-client';\r\nexport {\r\n    RevError,\r\n    ScrollError\r\n} from './rev-error';\r\nexport type {\r\n    AccessControl,\r\n    Admin,\r\n    Audit,\r\n    Auth,\r\n    Category,\r\n    Channel,\r\n    Device,\r\n    Group,\r\n    GuestRegistration,\r\n    OAuth,\r\n    Rev,\r\n    Role,\r\n    User,\r\n    Video,\r\n    Playlist,\r\n    Recording,\r\n    RegistrationField,\r\n    Webcast,\r\n    Zone\r\n\r\n} from './types';\r\n\r\nimport {rateLimit} from './utils';\r\nimport {getExtensionForMime, getMimeForExtension} from './utils/file-utils'\r\nexport const utils = {\r\n    rateLimit,\r\n    getExtensionForMime,\r\n    getMimeForExtension\r\n};\r\n\r\nimport { RevClient } from './rev-client';\r\nexport default RevClient;\r\n","const { toString: _toString } = Object.prototype;\r\n\r\nexport function isPlainObject<T = { [key: string]: any; } | any[]>(val: unknown): val is T {\r\n    if (_toString.call(val) !== '[object Object]') {\r\n        return false;\r\n    }\r\n    const prototype = Object.getPrototypeOf(val);\r\n    return prototype === null || prototype === Object.getPrototypeOf({ });\r\n}\r\n\r\nexport function isBlobLike(val: unknown): val is Blob | File {\r\n    return typeof (val as Blob)?.stream === 'function';\r\n}\r\n\r\nexport function isReadable<T = any>(val: unknown): val is AsyncIterable<T> {\r\n    return typeof (val as AsyncIterable<T>)[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\nexport function titleCase(val: string) {\r\n    return `${val[0]}${val.slice(1)}`;\r\n}\r\n\r\n// exclude 0 / false from falsy check\r\nexport function isBlank(val: any) {\r\n    return val == undefined || val === '';\r\n}\r\n","/**\r\n * There are slight differences in handling browser and node.js environments.\r\n * This folder wraps all components that get polyfilled in node.js, as well as\r\n * allowing uploading a video from the local filesystem on node.js\r\n */\r\nimport { isBlobLike } from '../utils/is-utils';\r\nimport type { UploadFileOptions, FileUploadPayloadInternal, FileUploadType } from '../utils/file-utils';\r\n\r\n\r\n/**\r\n * used in OAuth - get random verifier string\r\n * @param byteLength\r\n */\r\nfunction randomValues(byteLength: number) {\r\n    const values = crypto.getRandomValues(new Uint8Array(byteLength / 2));\r\n    return Array.from(values)\r\n        .map(c => c.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n/**\r\n * sha256 hash function for oauth2 pkce\r\n * @param value\r\n * @returns\r\n */\r\nasync function sha256Hash(value: string) {\r\n    const bytes = new TextEncoder().encode(value);\r\n    const hashed = await crypto.subtle.digest('SHA-256', bytes);\r\n    const binary = String.fromCharCode(...(new Uint8Array(hashed)));\r\n    return btoa(binary)\r\n        .replace(/\\//g, '_')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/=+$/, '');\r\n}\r\n\r\n\r\n/**\r\n * used to sign the verifier in OAuth workflow\r\n */\r\nasync function hmacSign(message: string, secret: string) {\r\n    const enc = new TextEncoder();\r\n    const cryptoKey = await crypto.subtle\r\n        .importKey(\r\n            'raw',\r\n            enc.encode(secret),\r\n            { name: 'HMAC', hash: 'SHA-256' },\r\n            true,\r\n            ['sign']\r\n        );\r\n    const signed = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));\r\n    return btoa(String.fromCharCode(...new Uint8Array(signed)));\r\n}\r\n\r\n\r\nexport default {\r\n    AbortController: globalThis.AbortController,\r\n    AbortSignal: globalThis.AbortSignal,\r\n    createAbortError(message: string): Error {\r\n        return new DOMException(message, 'AbortError');\r\n    },\r\n    fetch: (...args: Parameters<typeof fetch>) => globalThis.fetch(...args),\r\n    FormData: globalThis.FormData,\r\n    Headers: globalThis.Headers,\r\n    Request: globalThis.Request,\r\n    Response: globalThis.Response,\r\n    randomValues,\r\n    sha256Hash,\r\n    hmacSign,\r\n    /**\r\n     *\r\n     * @param file\r\n     * @param filename\r\n     * @param contentType\r\n     * @returns\r\n     */\r\n    async parseFileUpload(file: FileUploadType, options: UploadFileOptions): Promise<FileUploadPayloadInternal> {\r\n        let {\r\n            filename,\r\n            contentType,\r\n            contentLength\r\n        } = options;\r\n\r\n        if (isBlobLike(file)) {\r\n            const { type, name, size } = <File>file;\r\n            if (type && !contentType) {\r\n                contentType = type;\r\n            }\r\n            if (name && !filename) {\r\n                filename = name;\r\n            }\r\n            if (size && !contentLength) {\r\n                contentLength = size;\r\n            }\r\n\r\n            return {\r\n                file,\r\n                options: {\r\n                    ...options,\r\n                    filename,\r\n                    contentType,\r\n                    contentLength\r\n                }\r\n            };\r\n        }\r\n        throw new TypeError('Only Blob / Files are supported for file uploads. Pass a File/Blob object');\r\n    },\r\n    appendFileToForm(form: FormData, fieldName: string, payload: FileUploadPayloadInternal) {\r\n        const {\r\n            file,\r\n            options: {\r\n                filename\r\n            }\r\n        } = payload;\r\n        form.append(fieldName, file as Blob, filename);\r\n    },\r\n    async prepareUploadHeaders(form: FormData, headers: Headers, useChunkedTransfer?: boolean) {\r\n        // nothing - this is used for fixing node's form-data behavior\r\n    }\r\n};\r\n","import polyfills from '../interop';\r\n\r\nconst ONE_MINUTE = 60 * 1000;\r\n\r\ninterface RateLimitOptions{\r\n    /**\r\n     * how many to allow in parallel in any given interval\r\n     * @default 1\r\n     */\r\n    limit?: number,\r\n    /**\r\n     * interval in milliseconds\r\n     */\r\n    interval?: number,\r\n    /**\r\n     * set limit to X per second\r\n     */\r\n    perSecond?: number,\r\n    /**\r\n     * set limit to X per minute (can be fraction, i.e. 0.5 for 1 every 2 minutes)\r\n     */\r\n    perMinute?: number,\r\n    /**\r\n     * set limit to X per hour\r\n     */\r\n    perHour?: number,\r\n    /**\r\n     * cancel with AbortController\r\n     */\r\n    signal?: AbortSignal\r\n}\r\n\r\ntype ThrottledFunction<T extends (...args: any[]) => any> = (\r\n    (...args: Parameters<T>) => ReturnType<T> extends PromiseLike<infer Return> ? Promise<Return> : Promise<ReturnType<T>>\r\n) & {\r\n    /**\r\n    Abort pending executions. All unresolved promises are rejected with a `CancelError` error.\r\n    */\r\n    abort: () => void;\r\n};\r\n\r\ninterface RateLimitOptionsWithFn<T> extends RateLimitOptions {\r\n    /**\r\n     * function to rate limit\r\n     */\r\n    fn: T\r\n}\r\nfunction rateLimit<T extends (...args: any) => any>(options: RateLimitOptionsWithFn<T>): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T, options: RateLimitOptions): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T | RateLimitOptionsWithFn<T>, options?: RateLimitOptions): ThrottledFunction<T>;\r\n\r\n// adapted from https://github.com/sindresorhus/p-throttle\r\nfunction rateLimit<T extends (...args: any) => any> (fn: T | RateLimitOptionsWithFn<T>, options: RateLimitOptions = {}) {\r\n    if (fn && (typeof fn === 'object')) {\r\n        options = Object.assign({}, fn, options);\r\n        fn = undefined as unknown as T;\r\n    }\r\n    if (!fn) {\r\n        fn = (options as RateLimitOptionsWithFn<T>).fn;\r\n    }\r\n\r\n    if (typeof fn !== 'function') {\r\n        throw new TypeError('Rate limit function is not a function');\r\n    }\r\n\r\n    const {\r\n        perSecond,\r\n        perMinute,\r\n        perHour,\r\n        signal\r\n    } = options;\r\n\r\n    let limit = parseFloat(options.limit as unknown as string) || 1;\r\n    let interval = parseInt(options.interval as unknown as string, 10);\r\n\r\n    if (perSecond) {\r\n        limit = parseFloat(perSecond as unknown as string);\r\n        interval = 1000;\r\n    }\r\n    if (perMinute) {\r\n        limit = parseFloat(perMinute as unknown as string);\r\n        interval = ONE_MINUTE;\r\n    }\r\n    if (perHour) {\r\n        limit = parseFloat(perHour as unknown as string);\r\n        interval = ONE_MINUTE * 60;\r\n    }\r\n\r\n    if (limit < 1) {\r\n        interval *= limit;\r\n        limit = 1;\r\n    } else {\r\n        // just make sure it isn't a faction for some silly reason\r\n        limit = Math.floor(limit);\r\n    }\r\n\r\n    if (!Number.isFinite(limit)) {\r\n        throw new TypeError(`Invalid limit ${limit}`);\r\n    }\r\n\r\n    if (!Number.isFinite(interval) || interval <= 0) {\r\n        throw new TypeError('Invalid interval option');\r\n    }\r\n\r\n    const queue:Map<NodeJS.Timeout, (err: Error) => any> = new Map();\r\n\r\n    let currentTick = 0;\r\n    let activeCount = 0;\r\n\r\n    type Return = ReturnType<T> extends PromiseLike<infer R> ? Promise<R> : Promise<ReturnType<T>>;\r\n\r\n    const throttled = function (...args: Parameters<T>) {\r\n        let timeout: NodeJS.Timeout;\r\n        return new Promise((resolve, reject) => {\r\n            const execute = () => {\r\n                resolve((fn as T).apply(null, args));\r\n                queue.delete(timeout);\r\n            };\r\n\r\n            const now = Date.now();\r\n\r\n            if ((now - currentTick) > interval) {\r\n                activeCount = 1;\r\n                currentTick = now;\r\n            } else if (activeCount < limit) {\r\n                activeCount++;\r\n            } else {\r\n                currentTick += interval;\r\n                activeCount = 1;\r\n            }\r\n\r\n            timeout = setTimeout(execute, currentTick - now);\r\n\r\n            // used for sending cancel error\r\n            queue.set(timeout, reject);\r\n        }) as Return;\r\n    };\r\n\r\n    throttled.abort = (message: string = 'Cancelled rate-limit queue') => {\r\n        for (const [timeout, reject] of queue.entries()) {\r\n            clearTimeout(timeout);\r\n            reject(polyfills.createAbortError(message));\r\n        }\r\n\r\n        queue.clear();\r\n    };\r\n\r\n    if (signal) {\r\n        signal.addEventListener('abort', () => throttled.abort());\r\n    }\r\n\r\n    return throttled;\r\n}\r\n\r\nexport default rateLimit;\r\n","export {default as rateLimit} from './rate-limit';\r\n\r\nexport * from './is-utils';\r\n\r\nexport function asValidDate(val: string | Date | undefined): Date | undefined;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue: Date): Date;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue?: Date): Date | undefined {\r\n    if (!val) {\r\n        return defaultValue;\r\n    }\r\n    if (!(val instanceof Date)) {\r\n        val = new Date(val);\r\n    }\r\n    return isNaN(val.getTime())\r\n    ? defaultValue\r\n    : val;\r\n}\r\n\r\n/**\r\n * Retry a function multiple times, sleeping before attempts\r\n * @param {() => Promise<T>} fn function to attempt. Return value if no error thrown\r\n * @param {(err: Error, attempt: number) => boolean} [shouldRetry] callback on error.\r\n * @param {number} [maxAttempts] maximum number of retry attempts before throwing error\r\n * @param {number} [sleepMilliseconds] milliseconds to wait between attempts\r\n * @returns {Promise<T>}\r\n */\r\nexport async function retry<T, E extends Error>(fn: () => Promise<T>, shouldRetry: (err: E, attempt?: number) => boolean = () => true, maxAttempts: number = 3, sleepMilliseconds: number = 1000) {\r\n    let attempt = 0;\r\n    while (attempt < maxAttempts) {\r\n        try {\r\n            const result = await fn();\r\n            return result;\r\n        } catch (err: any) {\r\n            attempt += 1;\r\n            if (attempt >= maxAttempts || !shouldRetry(err, attempt)) {\r\n                throw err;\r\n            }\r\n            await sleep(sleepMilliseconds);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * delay async execution, with optional early exit using abort signal\r\n * @param ms\r\n * @param signal\r\n * @returns\r\n */\r\nexport async function sleep(ms: number, signal?: AbortSignal) {\r\n    return new Promise<void>(done => {\r\n        let timer: ReturnType<typeof setTimeout>;\r\n        const cleanup = () => {\r\n            clearTimeout(timer);\r\n            signal?.removeEventListener('abort', cleanup);\r\n            done();\r\n        };\r\n        timer = setTimeout(done, ms);\r\n        signal?.addEventListener('abort', cleanup);\r\n    });\r\n}\r\n\r\n/** try to parse as json */\r\nexport function tryParseJson(val: string): any {\r\n    if (val !== 'null' && val) {\r\n        try {\r\n            return JSON.parse(val);\r\n        } catch (err) {\r\n            // nothing\r\n        }\r\n    }\r\n    return null;\r\n};\r\n","import { isPlainObject, tryParseJson } from './utils';\r\n\r\nexport class RevError extends Error {\r\n    status: number;\r\n    url: string;\r\n    code: string;\r\n    detail: string;\r\n    constructor(response: Response, body: { [key: string]: any; } | string) {\r\n        const {\r\n            status = 500,\r\n            statusText = '',\r\n            url\r\n        } = response;\r\n        super(`${status} ${statusText}`);\r\n        // Chrome/node specific function\r\n        if ('captureStackTrace' in Error) {\r\n            (Error as any).captureStackTrace(this, this.constructor);\r\n        }\r\n\r\n        this.status = status;\r\n        this.url = url;\r\n        this.code = `${status}`;\r\n        this.detail = statusText;\r\n        // Some Rev API responses include additional details in its body\r\n        if (isPlainObject<Record<string, string>>(body)) {\r\n            if (body.code) {\r\n                this.code = body.code;\r\n            }\r\n            if (body.detail) {\r\n                this.detail = body.detail;\r\n            }\r\n        } else if (typeof body === 'string') {\r\n            body = body.trim();\r\n            // try to parse as JSON\r\n            if (body.startsWith('{')) {\r\n                const { code, detail } = tryParseJson(body) || { };\r\n                if (code) { this.code = code; }\r\n                if (detail) { this.detail = detail; }\r\n            } else if (this.status === 429) {\r\n                this.detail = 'Too Many Requests';\r\n            } else if (/^(<!DOCTYPE|<html)/.test(body)) {\r\n                // if html then strip out the extra cruft\r\n                this.detail = body\r\n                    .replace(/.*<body>\\s+/s, '')\r\n                    .replace(/<\\/body>.*/s, '')\r\n                    .slice(0, 256);\r\n            }\r\n        }\r\n    }\r\n    get name() {\r\n        return this.constructor.name;\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return this.constructor.name;\r\n    }\r\n    static async create(response: Response) {\r\n        let body: any;\r\n\r\n        try {\r\n            // retrieve body - constructor will decode as json\r\n            body = await response.text();\r\n        } catch (err) {\r\n            body = {\r\n                code: 'Unknown',\r\n                detail: `Unable to parse error response body: ${err}`\r\n            };\r\n        }\r\n        return new RevError(response, body);\r\n    }\r\n}\r\n\r\nexport class ScrollError extends Error {\r\n    status: number;\r\n    code: string;\r\n    detail: string;\r\n    constructor(status: number = 408, code: string = 'ScrollExpired', detail: string = 'Timeout while fetching all results in search request') {\r\n        super('Search Scroll Expired');\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.status = status;\r\n        this.code = code;\r\n        this.detail = detail;\r\n    }\r\n    get name() {\r\n        return this.constructor.name;\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return this.constructor.name;\r\n    }\r\n}\r\n","import { Rev } from '../types/rev';\r\n\r\nexport interface IPageResponse<T> {\r\n    items: T[],\r\n    done: boolean,\r\n    total?: number,\r\n    pageCount?: number,\r\n    error?: Error\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: await request.exec() == <array>\r\n * 2) Get each page of results: await request.nextPage() == { current, total, items: <array> }\r\n * 3) Use for await to get all results one at a time: for await (let hit of request) { }\r\n */\r\nexport abstract class PagedRequest<ItemType> implements Rev.ISearchRequest<ItemType> {\r\n    current: number;\r\n    total: number | undefined;\r\n    done: boolean;\r\n    options: Required<Rev.SearchOptions<ItemType>>;\r\n    constructor(options: Rev.SearchOptions<ItemType> = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            onProgress: (items: ItemType[], current: number, total?: number) => {},\r\n            onError: (err => { throw err; }),\r\n            onScrollError: (err => {\r\n                console.warn(\"DEPRECATED: use onError instead of onScrollError with rev search requests\");\r\n                this.options.onError(err);\r\n            }),\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = undefined;\r\n        this.done = false;\r\n    }\r\n    protected abstract _requestPage(): Promise<IPageResponse<ItemType>>;\r\n    /**\r\n     * Get the next page of results from API\r\n     */\r\n    async nextPage(): Promise<Rev.SearchPage<ItemType>> {\r\n        const {\r\n            onProgress,\r\n            onError\r\n        } = this.options;\r\n\r\n        if (this.done) {\r\n            return {\r\n                current: this.current,\r\n                total: this.current,\r\n                done: this.done,\r\n                items: []\r\n            };\r\n        }\r\n\r\n        const page = await this._requestPage();\r\n        const result = this._parsePage(page);\r\n\r\n        let {\r\n            current,\r\n            items,\r\n            total,\r\n            done,\r\n            error\r\n        } = result;\r\n\r\n        onProgress(items, current, total);\r\n\r\n        if (error) {\r\n            onError(error);\r\n        }\r\n\r\n        return {\r\n            current,\r\n            items,\r\n            total,\r\n            done\r\n        };\r\n    }\r\n    /**\r\n     * update internal variables based on API response\r\n     * @param page\r\n     * @returns\r\n     */\r\n    protected _parsePage(page: IPageResponse<ItemType>) {\r\n        const { maxResults } = this.options;\r\n\r\n        let {\r\n            items = [],\r\n            done = this.done,\r\n            total,\r\n            pageCount,\r\n            error,\r\n        } = page;\r\n\r\n        // let request function set done status\r\n        if (done) {\r\n            this.done = true;\r\n        }\r\n\r\n        // update total\r\n        if (isFinite(total!)) {\r\n            this.total = Math.min(total!, maxResults);\r\n        }\r\n\r\n        if (!pageCount) {\r\n            pageCount = items.length;\r\n        }\r\n\r\n        const current = this.current;\r\n\r\n        // limit results to specified max results\r\n        if (current + pageCount >= maxResults) {\r\n            pageCount = maxResults - current;\r\n            items = items.slice(0, pageCount);\r\n            this.done = true;\r\n        }\r\n\r\n        this.current += pageCount;\r\n\r\n        if (this.current === this.total) {\r\n            this.done = true;\r\n        }\r\n\r\n        if (this.done) {\r\n            // set total to current for results where not otherwise known in advance\r\n            this.total = this.current;\r\n        }\r\n\r\n        if (error) {\r\n            this.done = true;\r\n        }\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            error,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<ItemType[]> {\r\n        const results: ItemType[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    async* [Symbol.asyncIterator]() {\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n\r\n","import { ScrollError } from '../rev-error';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types';\r\nimport { IPageResponse, PagedRequest } from './paged-request';\r\n\r\nexport async function decodeBody(response: Response, acceptType?: string | null) {\r\n    const contentType = response.headers.get('Content-Type') || acceptType || '';\r\n\r\n    if (contentType.startsWith('application/json')) {\r\n        try {\r\n            return await response.json();\r\n        } catch (err) {\r\n            // keep going\r\n        }\r\n    }\r\n\r\n    if (contentType.startsWith('text')) {\r\n        return response.text();\r\n    }\r\n\r\n    return response.body;\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: await request.exec() == <array>\r\n * 2) Get each page of results: await request.nextPage() == { current, total, items: <array> }\r\n * 3) Use for await to get all results one at a time: for await (let hit of request) { }\r\n */\r\nexport class SearchRequest<T> extends PagedRequest<T> {\r\n    declare options: Required<Rev.SearchOptions<T>>;\r\n    private query: Record<string, any>;\r\n    private _reqImpl: () => Promise<IPageResponse<T>>;\r\n    constructor(\r\n        rev: RevClient,\r\n        searchDefinition: Rev.SearchDefinition<T>,\r\n        query: Record<string, any> = {},\r\n        options: Rev.SearchOptions<T> = {}\r\n    ) {\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                const {hitsKey} = searchDefinition;\r\n                rev.log('debug', `searching ${hitsKey}, ${current}-${current + items.length} of ${total}...`);\r\n            },\r\n            onError: (err => { throw err; }),\r\n            ...options\r\n        });\r\n\r\n        // make copy of query object\r\n        const {\r\n            scrollId: _ignore,\r\n            ...queryOpt\r\n        } = query;\r\n        this.query = queryOpt;\r\n\r\n        this._reqImpl = this._buildReqFunction(rev, searchDefinition);\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n    }\r\n    protected _requestPage() {\r\n        return this._reqImpl();\r\n    }\r\n    private _buildReqFunction(rev: RevClient, searchDefinition: Rev.SearchDefinition<T>) {\r\n        const {\r\n            endpoint,\r\n            totalKey,\r\n            hitsKey,\r\n            isPost = false,\r\n            request,\r\n            transform\r\n        } = searchDefinition;\r\n\r\n        const requestFn = request || (isPost\r\n            ? rev.post.bind(rev)\r\n            : rev.get.bind(rev)\r\n        );\r\n\r\n        return async () => {\r\n\r\n            const response: Record<string, any> = await requestFn(endpoint, this.query, { responseType: 'json' });\r\n\r\n            let {\r\n                scrollId,\r\n                [totalKey]: total,\r\n                [hitsKey]: rawItems = [],\r\n                statusCode,\r\n                statusDescription\r\n            } = response;\r\n\r\n            let done = false;\r\n\r\n            this.query.scrollId = scrollId;\r\n            if (!scrollId) {\r\n                done = true;\r\n            }\r\n\r\n            const items: T[] = (typeof transform === 'function')\r\n                ? await Promise.resolve(transform(rawItems))\r\n                : rawItems;\r\n\r\n            if (items.length === 0) {\r\n                done = true;\r\n            }\r\n\r\n            // check for error response\r\n            const error = (statusCode >= 400 && !!statusDescription)\r\n                ? new ScrollError(statusCode, statusDescription)\r\n                : undefined;\r\n\r\n            return {\r\n                total,\r\n                done,\r\n                pageCount: rawItems.length,\r\n                items,\r\n                error\r\n            };\r\n        };\r\n    }\r\n}\r\n","import { Admin, Rev, Role, RegistrationField } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n// if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache. false means bypass cache\r\ntype CacheOption = boolean | 'Force'\r\n\r\nexport default function adminAPIFactory(rev: RevClient) {\r\n    let roles: Role.Details[];\r\n    let customFields: Admin.CustomField[];\r\n\r\n    const adminAPI = {\r\n        /**\r\n        * get mapping of role names to role IDs\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async roles(cache: CacheOption = true): Promise<Role.Details[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (roles && cache === true) {\r\n                return roles;\r\n            }\r\n            const response = await rev.get('/api/v2/users/roles');\r\n            if (cache) {\r\n                roles = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Role (with the role id) based on its name\r\n        * @param name Name of the Role, i.e. \"Media Viewer\"\r\n        * @param fromCache - if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getRoleByName(name: Role.RoleName, fromCache: CacheOption = true): Promise<Role> {\r\n            const roles = await adminAPI.roles(fromCache);\r\n            const role = roles.find(r => r.name === name);\r\n            if (!role) {\r\n                throw new TypeError(`Invalid Role Name ${name}. Valid values are: ${roles.map(r => r.name).join(', ')}`);\r\n            }\r\n            return {\r\n                id: role.id,\r\n                name: role.name\r\n            };\r\n        },\r\n        /**\r\n        * get list of custom fields\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async customFields(cache: CacheOption = true): Promise<Admin.CustomField[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (customFields && cache === true) {\r\n                return customFields;\r\n            }\r\n            const response = await rev.get('/api/v2/video-fields', undefined, { responseType: 'json' });\r\n            if (cache) {\r\n                customFields = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Custom Field based on its name\r\n        * @param name name of the Custom Field\r\n        * @param fromCache if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getCustomFieldByName(name: string, fromCache: CacheOption = true): Promise<Admin.CustomField> {\r\n            const customFields = await adminAPI.customFields(fromCache);\r\n            const field = customFields.find(cf => cf.name === name);\r\n            if (!field) {\r\n                throw new TypeError(`Invalid Custom Field Name ${name}. Valid values are: ${customFields.map(cf => cf.name).join(', ')}`);\r\n            }\r\n            return field;\r\n        },\r\n        async brandingSettings(): Promise<Admin.BrandingSettings> {\r\n            return rev.get('/api/v2/accounts/branding-settings');\r\n        },\r\n        async webcastRegistrationFields(): Promise<RegistrationField & { id: string }> {\r\n            const response = await rev.get('/api/v2/accounts/webcast-registration-fields');\r\n            return response.registrationFields;\r\n        },\r\n        async createWebcastRegistrationField(registrationField: RegistrationField.Request): Promise<string> {\r\n            const response = await rev.post('/api/v2/accounts/webcast-registration-fields', registrationField);\r\n            return response.fieldId;\r\n        },\r\n        async updateWebcastRegistrationField(fieldId: string, registrationField: Partial<RegistrationField.Request>): Promise<void> {\r\n            return rev.put(`/api/v2/accounts/webcast-registration-fields/${fieldId}`, registrationField);\r\n        },\r\n        async deleteWebcastRegistrationField(fieldId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/accounts/webcast-registration-fields/${fieldId}`);\r\n        },\r\n        listIQCreditsUsage(query: { startDate?: string | Date, endDate?: string | Date }, options?: Rev.SearchOptions<Admin.IQCreditsSession>): SearchRequest<Admin.IQCreditsSession> {\r\n            const searchDefinition: Rev.SearchDefinition<Admin.IQCreditsSession> = {\r\n                endpoint: `/api/v2/analytics/accounts/iq-credits-usage`,\r\n                totalKey: 'total',\r\n                hitsKey: 'sessions'\r\n            };\r\n            return new SearchRequest<Admin.IQCreditsSession>(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n        * get system health - returns 200 if system is active and responding, otherwise throws error\r\n        */\r\n        async verifySystemHealth(): Promise<boolean> {\r\n            await rev.get('/api/v2/system-health');\r\n            return true;\r\n        },\r\n        /**\r\n        * gets list of scheduled maintenance windows\r\n        */\r\n        async maintenanceSchedule(): Promise<{start: string, end: string}[]> {\r\n            const {schedules} = await rev.get('/api/v2/maintenance-schedule');\r\n            return schedules;\r\n        },\r\n        /**\r\n         * gets the user location service URL\r\n         */\r\n        async userLocationService(): Promise<{ enabled: boolean, locationUrls: string[] }> {\r\n            return rev.get('/api/v2/user-location');\r\n        },\r\n        /**\r\n         * returns an array of all expiration rules\r\n         */\r\n        async expirationRules(): Promise<Admin.ExpirationRule[]> {\r\n            return rev.get('/api/v2/expiration-rules');\r\n        }\r\n    };\r\n    return adminAPI;\r\n}\r\n","/**\r\n * simple helper function to parse CSV data into JSON\r\n */\r\nexport function parseCSV(raw: string) {\r\n    raw = raw.replace(/(\\r\\n|\\n|\\r)/gm, '\\n').replace(/\\n$/g, '');\r\n\r\n    let cur = '';\r\n    let inQuote = false;\r\n    let fieldQuoted = false;\r\n    let field: string | undefined = '';\r\n    let row: (string | undefined)[] = [];\r\n    let out: (string | undefined)[][] = [];\r\n    let i: number;\r\n    const n = raw.length;\r\n\r\n    function processField(field: string) {\r\n        if (fieldQuoted) { return field; }\r\n        if (field === '') { return undefined; }\r\n        return field.trim();\r\n    }\r\n\r\n    for (i = 0; i < n; i += 1) {\r\n        cur = raw.charAt(i);\r\n\r\n        if (!inQuote && (cur === ',' || cur === '\\n')) {\r\n            field = processField(field);\r\n            row.push(field);\r\n            if (cur === '\\n') {\r\n                out.push(row);\r\n                row = [];\r\n            }\r\n            field = '';\r\n            fieldQuoted = false;\r\n        } else if (cur === '\"') {\r\n            if (!inQuote) {\r\n                inQuote = true;\r\n                fieldQuoted = true;\r\n            } else {\r\n                if (raw.charAt(i + 1) === '\"') {\r\n                    field += '\"';\r\n                    i += 1;\r\n                } else {\r\n                    inQuote = false;\r\n                }\r\n            }\r\n        } else {\r\n            field += cur === '\\n' ? '\\n' : cur;\r\n        }\r\n    }\r\n\r\n    // Add the last field\r\n    field = processField(field);\r\n    row.push(field);\r\n    out.push(row);\r\n\r\n    const headers: string[] = out.shift() as string[];\r\n    return out\r\n        .map((line: (string | undefined)[]) => {\r\n            const obj: Record<string, string> = { };\r\n            line\r\n                .forEach((field, i) => {\r\n                    if (field !== undefined) {\r\n                        obj[headers[i]] = field;\r\n                    }\r\n                });\r\n            return obj;\r\n        });\r\n}\r\n","import { RevClient } from '..';\r\nimport { Audit } from '../types';\r\nimport { asValidDate, tryParseJson } from '../utils';\r\nimport { IPageResponse, PagedRequest } from '../utils/paged-request';\r\nimport { parseCSV } from '../utils/parse-csv';\r\n\r\nfunction parseEntry<T extends Audit.Entry>(line: Record<string, any>): T {\r\n    return {\r\n        messageKey: line['MessageKey'],\r\n        entityKey: line['EntityKey'],\r\n        when: line['When'],\r\n        principal: tryParseJson(line['Principal']) || {},\r\n        message: tryParseJson(line['Message']) || {},\r\n        currentState: tryParseJson(line['CurrentState']) || {},\r\n        previousState: tryParseJson(line['PreviousState']) || {}\r\n    } as T;\r\n}\r\n\r\nexport class AuditRequest<T extends Audit.Entry> extends PagedRequest<T> {\r\n    declare options: Required<Omit<Audit.Options<T>, 'toDate' | 'fromDate'>>;\r\n    private params: {\r\n        toDate?: string,\r\n        fromDate?: string,\r\n        nextContinuationToken?: string;\r\n    }\r\n    private _req: () => Promise<IPageResponse<T>>;\r\n    constructor(\r\n        rev: RevClient,\r\n        endpoint: string,\r\n        label: string = 'audit records',\r\n        {toDate, fromDate, ...options}: Audit.Options<T> = {}\r\n    ) {\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                rev.log('debug', `loading ${label}, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        });\r\n\r\n        const {from, to} = this._parseDates(fromDate, toDate);\r\n\r\n        this.params = {\r\n            toDate: to.toISOString(),\r\n            fromDate: from.toISOString()\r\n        };\r\n\r\n        this._req = this._buildReqFunction(rev, endpoint);\r\n    }\r\n    protected _requestPage() { return this._req(); }\r\n    private _buildReqFunction(rev: RevClient, endpoint: string) {\r\n        return async () => {\r\n            const response = await rev.request('GET', endpoint, { params: this.params }, { responseType: 'text' });\r\n\r\n            const {\r\n                body,\r\n                headers\r\n            } = response;\r\n\r\n            let items = parseCSV(body)\r\n                .map(line => parseEntry<T>(line));\r\n\r\n            const total = parseInt(headers.get('totalRecords') || '', 10);\r\n\r\n            Object.assign(this.params, {\r\n                nextContinuationToken: headers.get('nextContinuationToken') || undefined,\r\n                fromDate: headers.get('nextfromDate') || undefined\r\n            });\r\n\r\n            let done = !this.params.nextContinuationToken;\r\n\r\n\r\n            return {\r\n                items,\r\n                total,\r\n                done\r\n            } as IPageResponse<T>;\r\n        }\r\n    }\r\n    private _parseDates(fromDate?: Date | string, toDate?: Date | string) {\r\n        let to = asValidDate(toDate, new Date());\r\n\r\n        // default to one year older than toDate\r\n        const defaultFrom = new Date(to.setFullYear(to.getFullYear() - 1));\r\n\r\n        let from = asValidDate(fromDate, defaultFrom);\r\n\r\n        if (to < from) {\r\n            [to, from] = [from, to];\r\n        }\r\n        return {from, to};\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Audit } from '../types';\r\nimport { AuditRequest } from './audit-request';\r\n\r\nexport default function auditAPIFactory(rev: RevClient) {\r\n    const auditAPI = {\r\n        /**\r\n        * Logs of user login / logout / failed login activity\r\n        */\r\n        accountAccess(accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess`, 'UserAccess', options);\r\n        },\r\n        userAccess(userId: string, accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess/${userId}`, `UserAccess_${userId}`, options);\r\n        },\r\n        /**\r\n        * Operations on User Records (create, delete, etc)\r\n        */\r\n        accountUsers(accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users`, 'User', options);\r\n        },\r\n        user(userId: string, accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users/${userId}`, 'User', options);\r\n        },\r\n        /**\r\n        * Operations on Group Records (create, delete, etc)\r\n        */\r\n        accountGroups(accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups`, 'Groups', options);\r\n        },\r\n        group(groupId: string, accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups/${groupId}`, 'Group', options);\r\n        },\r\n        /**\r\n        * Operations on Device Records (create, delete, etc)\r\n        */\r\n        accountDevices(accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices`, 'Devices', options);\r\n        },\r\n        device(deviceId: string, accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices/${deviceId}`, 'Device', options);\r\n        },\r\n        /**\r\n        * Operations on Video Records (create, delete, etc)\r\n        */\r\n        accountVideos(accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos`, 'Videos', options);\r\n        },\r\n        video(videoId: string, accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos/${videoId}`, 'Video', options);\r\n        },\r\n        /**\r\n        * Operations on Webcast Records (create, delete, etc)\r\n        */\r\n        accountWebcasts(accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents`, 'Webcasts', options);\r\n        },\r\n        webcast(eventId: string, accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents/${eventId}`, `Webcast`, options);\r\n        },\r\n        /**\r\n        * All operations a single user has made\r\n        */\r\n        principal(userId: string, accountId: string, options?: Audit.Options<Audit.Entry<string>>) {\r\n            return new AuditRequest<Audit.Entry<string>>(rev, `/network/audit/accounts/${accountId}/principals/${userId}`, 'Principal', options);\r\n        }\r\n    };\r\n\r\n    return auditAPI;\r\n}\r\n","import type { OAuth } from '../types/auth';\r\nimport polyfills from '../interop';\r\nimport type { Rev } from '../types/rev';\r\n\r\nconst PLACEHOLDER = 'http://rev';\r\n\r\nexport function getOAuth2AuthorizationUrl(config: OAuth.ServerConfig, code_challenge: string, state?: string) {\r\n    // construct URL with query params\r\n    const url = new URL('/api/v2/oauth2/authorize', config.revUrl);\r\n    url.search = new URLSearchParams({\r\n        client_id: config.oauthApiKey,\r\n        code_challenge,\r\n        response_type: 'code',\r\n        redirect_uri: config.redirectUri,\r\n        ...state && {state}\r\n    }).toString();\r\n\r\n    return url.toString();\r\n}\r\n\r\n/**\r\n *\r\n * @param codeVerifier value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n */\r\nexport async function getOAuth2PKCEVerifier(codeVerifier = polyfills.randomValues(48)) {\r\n    // setup pkce\r\n    // value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n    // this line uses random values to create 64char string\r\n    const codeChallenge = await polyfills.sha256Hash(codeVerifier);\r\n    return { codeVerifier, codeChallenge };\r\n}\r\n\r\n/**\r\n * Constructs the query parameters for the Rev /oauth/authorization endpoint\r\n * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page, along with revUrl\r\n * @param state optional state to pass back to redirectUri once complete\r\n * @returns A valid oauth flow endpoint + query\r\n */\r\nexport async function buildLegacyOAuthQuery(config: OAuth.Config, oauthSecret: string, state: string = '1') {\r\n    const { hmacSign } = polyfills;\r\n\r\n    const RESPONSE_TYPE = 'code';\r\n\r\n    const {\r\n        oauthApiKey: apiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const timestamp = new Date();\r\n    const verifier = `${apiKey}::${timestamp.toISOString()}`;\r\n\r\n    const signature = await hmacSign(verifier, oauthSecret);\r\n\r\n    return {\r\n        apiKey,\r\n        signature,\r\n        verifier,\r\n        'redirect_uri': redirectUri,\r\n        'response_type': RESPONSE_TYPE,\r\n        state\r\n    };\r\n}\r\n\r\n/**\r\n * Parse the query parameters returned to the redirectUri from Rev\r\n * @param url The URL with query parameters, or object with the query parrameters\r\n * @returns\r\n */\r\nexport function parseLegacyOAuthRedirectResponse(url: string | URL | URLSearchParams | Record<string, string>): OAuth.RedirectResponse {\r\n    if (typeof url === 'string') {\r\n        // just in case only the query string is returned, include base\r\n        url = new URL(url, PLACEHOLDER);\r\n    }\r\n\r\n    if (url instanceof URL) {\r\n        url = url.searchParams;\r\n    }\r\n\r\n    const query: Record<string, string> = (url instanceof URLSearchParams)\r\n        ? Object.fromEntries(url)\r\n        : url;\r\n\r\n    const {\r\n        'auth_code': authCode = '',\r\n        state = '',\r\n        error = undefined\r\n    } = query;\r\n\r\n    return {\r\n        isSuccess: !error,\r\n        // URL parsing parses pluses (+) as spaces, which can cause later validation to fail\r\n        authCode: `${authCode}`.replace(/ /g, '+'),\r\n        state,\r\n        error\r\n    };\r\n}\r\n\r\n/**\r\n * Format the oauth configuration and oauth response into the constructor arguments for RevClient\r\n * @param revUrl\r\n * @param config\r\n * @param response\r\n * @returns {Rev.Options}\r\n */\r\nexport function buildLegacyOAuthRevOptions(revUrl: string, config: OAuth.Config, response: OAuth.RedirectResponse): Rev.Options {\r\n    const {\r\n        oauthApiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const {\r\n        authCode\r\n    } = response;\r\n\r\n    return {\r\n        url: revUrl,\r\n        authCode,\r\n        oauthConfig: {\r\n            oauthApiKey,\r\n            redirectUri\r\n        }\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { Auth, OAuth } from '../types/auth';\r\nimport {buildLegacyOAuthQuery, getOAuth2AuthorizationUrl, getOAuth2PKCEVerifier, parseLegacyOAuthRedirectResponse} from './oauth';\r\n\r\nexport default function authAPIFactory(rev: RevClient) {\r\n\r\n    const authAPI = {\r\n        async loginToken(apiKey: string, secret: string): Promise<Auth.LoginResponse> {\r\n            return rev.post('/api/v2/authenticate', {\r\n                apiKey,\r\n                secret\r\n            });\r\n        },\r\n        async extendSessionToken(apiKey: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post(`/api/v2/auth/extend-session-timeout/${apiKey}`);\r\n        },\r\n        async logoffToken(apiKey: string): Promise<void> {\r\n            return rev.delete(`/api/v2/tokens/${apiKey}`);\r\n        },\r\n        async loginUser(username: string, password: string): Promise<Auth.UserLoginResponse> {\r\n            return rev.post('/api/v2/user/login', {\r\n                username,\r\n                password\r\n            });\r\n        },\r\n        async logoffUser(userId: string): Promise<void> {\r\n            return rev.post('/api/v2/user/logoff', { userId });\r\n        },\r\n        async extendSessionUser(userId: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session-timeout', { userId });\r\n        },\r\n        async loginJWT(jwtToken: string): Promise<Auth.JWTLoginResponse> {\r\n            return rev.get('/api/v2/jwtauthenticate', { jwt_token: jwtToken });\r\n        },\r\n        async extendSession(): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session');\r\n        },\r\n        async verifySession(): Promise<void> {\r\n            return rev.get('/api/v2/user/session');\r\n        },\r\n\r\n        /**\r\n         * @deprecated - use logoffUser - put here because it's a common misspelling\r\n         */\r\n        get logoutUser() { return authAPI.logoffUser; },\r\n        /**\r\n         * @deprecated - use logoffToken - put here because it's a common misspelling\r\n         */\r\n        get logoutToken() { return authAPI.logoffToken; },\r\n        /**\r\n         * generate the Authorization URL for the OAuth2 flow as well as the codeVerifier for the\r\n         * subsequent Access Token request. You *must* store the codeVerifier somehow (i.e. serverside database matched to user's state/cookies/session, or on browser SessionStorage) to be able to complete the OAuth2 login flow.\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param oauthSecret Secret from Rev Admin -> Security. This is a DIFFERENT value from the\r\n         *                    User Secret used for API login. Do not expose client-side!\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @param verifier the code_verifier to use when generating the code challenge. Can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]. If not provided then code will automatically generate a suitable value\r\n         * @returns A valid oauth flow URL + the code_verifier to save for later verification\r\n         */\r\n        async buildOAuth2Authentication(config: OAuth.ServerConfig, state: string = '1', verifier?: string): Promise<OAuth.AuthenticationData> {\r\n            const {codeChallenge, codeVerifier} = await getOAuth2PKCEVerifier(verifier);\r\n            const url = getOAuth2AuthorizationUrl(config, codeChallenge, state);\r\n            return {\r\n                url: `${url}`,\r\n                codeVerifier\r\n            };\r\n        },\r\n        async loginOAuth2(config: OAuth.Config, code: string, codeVerifier: string): Promise<OAuth.AuthTokenResponse> {\r\n            return rev.post('/api/v2/oauth2/token', {\r\n                // sometimes the authCode can get mangled, with the pluses in the code being replaced by spaces.\r\n                code: code.replace(/ /g, '+'),\r\n                client_id: config.oauthApiKey,\r\n                grant_type: 'authorization_code',\r\n                redirect_uri: config.redirectUri,\r\n                code_verifier: codeVerifier\r\n            });\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param oauthSecret Secret from Rev Admin -> Security. This is a DIFFERENT value from the\r\n         *                    User Secret used for API login. Do not expose client-side!\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @returns A valid oauth flow URL\r\n         */\r\n        async buildOAuthAuthenticationURL(config: OAuth.Config, oauthSecret: string, state: string = '1'): Promise<string> {\r\n            const query = await buildLegacyOAuthQuery(config, oauthSecret, state);\r\n            const url = new URL('/api/v2/oauth/authorization', rev.url);\r\n            url.search = `${new URLSearchParams(query)}`;\r\n            return `${url}`;\r\n        },\r\n        /**\r\n         * @deprecated\r\n         */\r\n        buildOAuthAuthenticationQuery: buildLegacyOAuthQuery,\r\n        /**\r\n         * @deprecated\r\n         */\r\n        parseOAuthRedirectResponse: parseLegacyOAuthRedirectResponse,\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param authCode\r\n         * @returns\r\n         */\r\n        async loginOAuth(config: OAuth.Config, authCode: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_AUTH = 'authorization_code';\r\n\r\n            const {\r\n                oauthApiKey: apiKey,\r\n                redirectUri\r\n            } = config;\r\n\r\n            // sometimes the authCode can get mangled, with the pluses in the code\r\n            // being replaced by spaces. This is just to make sure that isn't a problem (even though already done in parseOAuthRedirectResponse)\r\n            authCode = authCode.replace(/ /g, '+');\r\n\r\n            // COMBAK I don't think it matters if rev-client is logged in and passing Authorization headers or not.\r\n            return rev.post('/api/v2/oauth/token', {\r\n                authCode,\r\n                apiKey,\r\n                redirectUri,\r\n                grantType: GRANT_AUTH\r\n            });\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param refreshToken\r\n         * @returns\r\n         */\r\n        async extendSessionOAuth(config: OAuth.Config, refreshToken: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_REFRESH = 'refresh_token';\r\n\r\n            const {\r\n                oauthApiKey: apiKey\r\n            } = config;\r\n\r\n            return rev.post('/api/v2/oauth/token', {\r\n                apiKey,\r\n                refreshToken,\r\n                grantType: GRANT_REFRESH\r\n            });\r\n        }\r\n    };\r\n\r\n    return authAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Category } from '../types';\r\n\r\nexport default function categoryAPIFactory(rev: RevClient) {\r\n    const categoryAPI = {\r\n        async create(category: Category.CreateRequest): Promise<Category.CreateResponse> {\r\n            return rev.post('/api/v2/categories', category, { responseType: 'json' });\r\n        },\r\n        async details(categoryId: string): Promise<Category.Details> {\r\n            return rev.get(`/api/v2/categories/${categoryId}`, undefined, { responseType: 'json' });\r\n        },\r\n        async update(categoryId: string, category: Category.EditRequest): Promise<void> {\r\n            return rev.put(`/api/v2/categories/${categoryId}`, category);\r\n        },\r\n        async delete(categoryId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/categories/${categoryId}`);\r\n        },\r\n        /**\r\n         * get list of categories in system\r\n         * @see {@link https://revdocs.vbrick.com/reference#getcategories}\r\n         */\r\n        async list(parentCategoryId?: string, includeAllDescendants?: boolean): Promise<Category[]> {\r\n            // only pass parameters if defined\r\n            const payload: Record<string, any> = Object.assign(\r\n                { },\r\n                parentCategoryId && { parentCategoryId },\r\n                includeAllDescendants != undefined && { includeAllDescendants }\r\n            );\r\n            const { categories } = await rev.get('/api/v2/categories', payload, { responseType: 'json' });\r\n            return categories;\r\n        },\r\n        /**\r\n         * get list of categories that current user has ability to add videos to\r\n         */\r\n        async listAssignable(): Promise<Category.Assignable[]> {\r\n            return rev.get('/api/v2/assignable-categories');\r\n        }\r\n    };\r\n    return categoryAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Channel, Rev } from '../types';\r\n\r\nexport default function channelAPIFactory(rev: RevClient) {\r\n    const channelAPI = {\r\n        async create(channel: Channel.CreateRequest): Promise<string> {\r\n            const {channelId} = await rev.post('/api/v2/channels', channel, { responseType: 'json' });\r\n            return channelId;\r\n        },\r\n        async update(channelId: string, channel: Channel.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/channels/${channelId}`, channel);\r\n        },\r\n        async delete(channelId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/channels/${channelId}`);\r\n        },\r\n        /**\r\n         * get list of channels in system\r\n         * @see {@link https://revdocs.vbrick.com/reference/getchannels}\r\n         */\r\n        list(start: number = 0, options: Channel.SearchOptions = {}): ChannelListRequest {\r\n            return new ChannelListRequest(rev, start, options);\r\n        },\r\n        async addMembers(channelId: string, members: Channel.Member[]) {\r\n            const operations = members\r\n                .map(member => {\r\n                    return { op: 'add', path: '/Members/-', value: member };\r\n                });\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        },\r\n        async removeMembers(channelId: string, members: Array<string | Channel.Member>) {\r\n            const operations = members\r\n                .map(member => {\r\n                    const entityId = typeof member === 'string'\r\n                        ? member\r\n                        : member.id;\r\n\r\n                    return { op: 'remove', path: '/Members', value: entityId };\r\n                });\r\n\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        }\r\n    };\r\n    return channelAPI;\r\n}\r\n\r\nexport class ChannelListRequest implements Rev.ISearchRequest<Channel.SearchHit> {\r\n    currentPage: number;\r\n    current: number;\r\n    total: number;\r\n    done: boolean;\r\n    options: Required<Pick<Channel.SearchOptions, 'maxResults' | 'onProgress' | 'pageSize'>>;\r\n    private _req: () => Promise<Channel.SearchHit[]>;\r\n    constructor(rev: RevClient, start: number = 0, options: Channel.SearchOptions = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            pageSize: 10,\r\n            onProgress: (items: Channel.SearchHit[], current: number, total: number) => {\r\n                rev.log('debug', `loading channels, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n        this.currentPage = start;\r\n\r\n        this._req = () => {\r\n            const params = {\r\n                page: this.currentPage,\r\n                size: this.options.pageSize\r\n            };\r\n            return rev.get('/api/v2/channels', params, { responseType: 'json' });\r\n        }\r\n\r\n    }\r\n    async nextPage() {\r\n        const {\r\n            maxResults,\r\n            onProgress\r\n        } = this.options;\r\n\r\n        let current = this.current;\r\n\r\n        let items: Channel.SearchHit[] = await this._req();\r\n\r\n        if (!Array.isArray(items) || items.length == 0) {\r\n            this.done = true;\r\n            items = [];\r\n        }\r\n\r\n        if (current + items.length >= maxResults) {\r\n            const delta = maxResults - current;\r\n            items = items.slice(0, delta);\r\n            this.done = true;\r\n        }\r\n        this.total = current + items.length;\r\n\r\n        onProgress(items, current, this.total);\r\n\r\n        this.current += items.length;\r\n        this.currentPage += 1;\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<Channel.SearchHit[]> {\r\n        const results: Channel.SearchHit[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    async* [Symbol.asyncIterator]() {\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\n\r\nimport type { Device } from '../types';\r\n\r\nexport default function deviceAPIFactory(rev: RevClient) {\r\n    const deviceAPI = {\r\n        async listDMEs(): Promise<Device.DmeDetails[]> {\r\n            const response = await rev.get('/api/v2/devices/dmes');\r\n            return response.devices;\r\n        },\r\n        async listZoneDevices(): Promise<Device.ZoneDevice[]> {\r\n            const response = await rev.get('/api/v2/zonedevices');\r\n            return response.devices;\r\n        },\r\n        async listPresentationProfiles(): Promise<Device.PresentationProfile[]> {\r\n            return rev.get('/api/v2/presentation-profiles');\r\n        },\r\n        async add(dme: Device.CreateDMERequest) {\r\n            return rev.post('/api/v2/devices/dmes', dme);\r\n        },\r\n        async healthStatus(deviceId: string): Promise<Device.DmeHealthStatus> {\r\n            return rev.get(`/api/v2/devices/dmes/${deviceId}/health-status`);\r\n        },\r\n        async delete(deviceId: string) {\r\n            return rev.delete(`/api/v2/devices/dmes/${deviceId}`);\r\n        },\r\n        async rebootDME(deviceId: string) {\r\n            return rev.put(`/api/v2/devices/dmes/${deviceId}`);\r\n        }\r\n    };\r\n    return deviceAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Group, Rev, User } from '../types';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nexport default function groupAPIFactory(rev: RevClient) {\r\n    const groupAPI = {\r\n        /**\r\n         * Create a group. Returns the resulting Group ID\r\n         * @param {{name: string, userIds: string[], roleIds: string[]}} group\r\n         * @returns {Promise<string>}\r\n         */\r\n        async create(group: Group.CreateRequest) {\r\n            const { groupId } = await rev.post('/api/v2/groups', group);\r\n            return groupId;\r\n        },\r\n        async delete(groupId: string) {\r\n            await rev.delete(`/api/v2/groups/${groupId}`);\r\n        },\r\n        async details(groupId: string): Promise<Group.Details> {\r\n            return rev.get(`/api/v2/groups/${groupId}`);\r\n        },\r\n        /**\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.SearchOptions<Group.SearchHit> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/search/access-entity',\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                transform: (hits: Group.RawSearchHit[]) => hits.map(formatGroupSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'group' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest<Group.SearchHit>(rev, searchDefinition, query, options);\r\n        },\r\n        list(options: Rev.SearchOptions<Group.SearchHit> = { }) {\r\n            return groupAPI.search(undefined, options);\r\n        },\r\n        listUsers(groupId: string, options: Rev.SearchOptions<string> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds'\r\n            };\r\n            return new SearchRequest<string>(rev, searchDefinition, undefined, options);\r\n        },\r\n        /**\r\n         * get all users in a group with full details\r\n         * @param groupId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        listUserDetails(groupId: string, options: Rev.SearchOptions<User & { error?: Error }> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds',\r\n                transform: async (userIds: string[]) => {\r\n                    const result: User[] = [];\r\n                    for (let userId of userIds) {\r\n                        const out: User & {error: Error} = { userId } as any;\r\n                        try {\r\n                            const details = await rev.user.details(userId);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            return new SearchRequest<User & {userId: string, error?: Error}>(rev, searchDefinition, undefined, options);\r\n        }\r\n    };\r\n    return groupAPI;\r\n}\r\n\r\nfunction formatGroupSearchHit(hit: Group.RawSearchHit): Group.SearchHit {\r\n    return {\r\n        id: hit.Id,\r\n        name: hit.Name,\r\n        entityType: hit.EntityType\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Playlist } from '../types/playlist';\r\nimport { isPlainObject } from '../utils';\r\n\r\nexport default function playlistAPIFactory(rev: RevClient) {\r\n    const playlistAPI = {\r\n        async create(name: string, videoIds: string[]): Promise<string> {\r\n            const payload = {\r\n                name,\r\n                videoIds\r\n            };\r\n            const { playlistId } = await rev.post('/api/v2/playlists', payload, { responseType: 'json' });\r\n            return playlistId;\r\n        },\r\n        async update(playlistId: string, actions: Playlist.UpdateAction[]): Promise<void> {\r\n            const payload = {\r\n                playlistVideoDetails: actions\r\n            };\r\n            return rev.put(`/api/v2/playlists/${playlistId}`, payload);\r\n        },\r\n        async updateFeatured(actions: Playlist.UpdateAction[]): Promise<void> {\r\n            const payload = {\r\n                playlistVideoDetails: actions\r\n            };\r\n            return rev.put(`/api/v2/playlists/featured-playlist`, payload);\r\n        },\r\n        async delete(playlistId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/playlists/${playlistId}`);\r\n        },\r\n        /**\r\n         * get list of playlists in system.\r\n         * NOTE: return type is slightly different than API documentation\r\n         * @see {@link https://revdocs.vbrick.com/reference#getplaylists}\r\n         */\r\n        async list(): Promise<Playlist.List> {\r\n            // ensure raw response is in consistent format\r\n            function parsePlaylist(entry: Record<string, string> & { videos: any; }): Playlist {\r\n                return {\r\n                    id: entry.id ?? entry.playlistId ?? entry.featurePlaylistId ?? entry.featuredPlaylist,\r\n                    name: entry.name ?? entry.playlistName,\r\n                    playbackUrl: entry.playbackUrl,\r\n                    videos: entry.videos ?? entry.Videos as any\r\n                };\r\n            }\r\n\r\n            const rawResult = await rev.get('/api/v2/playlists', { responseType: 'json' });\r\n            // rawResult may return in strange format, so cleanup and return consistent output\r\n\r\n            const hasFeatured = !Array.isArray(rawResult);\r\n\r\n            const rawPlaylists = hasFeatured\r\n                ? rawResult.playlists\r\n                : rawResult;\r\n\r\n\r\n            const output: Playlist.List = {\r\n                playlists: rawPlaylists.map(parsePlaylist)\r\n            };\r\n\r\n            if (hasFeatured) {\r\n                if (isPlainObject(rawResult.featuredPlaylist)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult.featuredPlaylist);\r\n                } else if (Array.isArray(rawResult.videos)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult);\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n    };\r\n    return playlistAPI;\r\n}\r\n","import { Recording } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Video } from '../types/video';\r\nimport { isPlainObject } from '../utils';\r\n\r\nexport default function recordingAPIFactory(rev: RevClient) {\r\n    const recordingAPI = {\r\n        async startVideoConferenceRecording(sipAddress: string, sipPin: string, title?: string): Promise<string> {\r\n            const { videoId } = await rev.post('/api/v2/vc/start-recording', { title, sipAddress, sipPin }, { responseType: 'json' });\r\n            return videoId;\r\n        },\r\n        async getVideoConferenceStatus(videoId: string): Promise<Video.StatusEnum> {\r\n            const { status } = await rev.get(`/api/v2/vc/recording-status/${videoId}`, undefined, { responseType: 'json' });\r\n            return status;\r\n        },\r\n        async stopVideoConferenceRecording(videoId: string): Promise<string> {\r\n            const payload = { videoId };\r\n            const result = await rev.post(`/api/v2/vc/stop-recording`, payload, { responseType: 'json' });\r\n            return isPlainObject<{ message: string; }>(result)\r\n                ? result.message\r\n                : result;\r\n        },\r\n        async startPresentationProfileRecording(request: Recording.PresentationProfileRequest): Promise<string> {\r\n            const { scheduledRecordingId } = await rev.post('/api/v2/pp/start-recording', request, { responseType: 'json' });\r\n            return scheduledRecordingId;\r\n        },\r\n        async getPresentationProfileStatus(recordingId: string): Promise<Recording.PresentationProfileStatus> {\r\n            const result = await rev.get(`/api/v2/pp/recording-status/${recordingId}`, undefined, { responseType: 'json' });\r\n            return result;\r\n        },\r\n        async stopPresentationProfileRecording(recordingId: string): Promise<Recording.StopPresentationProfileResponse> {\r\n            const payload = { scheduledRecordingId: recordingId };\r\n            const result = await rev.get(`/api/v2/vc/recording-status`, payload, { responseType: 'json' });\r\n            return result;\r\n        }\r\n    };\r\n    return recordingAPI;\r\n}\r\n","import polyfills from '../interop';\r\nimport { isBlobLike } from './is-utils';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types';\r\n\r\nexport type FileUploadType = string | File | Blob | AsyncIterable<any>;\r\nexport interface UploadFileOptions {\r\n    /** specify filename of video as reported to Rev */\r\n    filename?: string;\r\n    /** specify content type of video */\r\n    contentType?: string;\r\n    /** if content length is known this will avoid needing to detect it */\r\n    contentLength?: number;\r\n    /** node-only - bypass dealing with content length and just upload as transfer-encoding: chunked */\r\n    useChunkedTransfer?: boolean;\r\n    /** An AbortSignal to set request's signal. */\r\n    signal?: AbortSignal | null;\r\n}\r\nexport interface FileUploadPayloadInternal {\r\n    file: FileUploadType;\r\n    options: UploadFileOptions;\r\n}\r\n\r\nexport const mimeTypes = {\r\n    '.7z': 'application/x-7z-compressed',\r\n    '.asf': 'video/x-ms-asf',\r\n    '.avi': 'video/x-msvideo',\r\n    '.csv': 'text/csv',\r\n    '.doc': 'application/msword',\r\n    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    '.f4v': 'video/x-f4v',\r\n    '.flv': 'video/x-flv',\r\n    '.gif': 'image/gif',\r\n    '.jpg': 'image/jpeg',\r\n    '.m4a': 'audio/mp4',\r\n    '.m4v': 'video/x-m4v',\r\n    '.mkv': 'video/x-matroska',\r\n    '.mov': 'video/quicktime',\r\n    '.mp3': 'audio/mpeg',\r\n    '.mp4': 'video/mp4',\r\n    '.mpg': 'video/mpeg',\r\n    '.pdf': 'application/pdf',\r\n    '.png': 'image/png',\r\n    '.ppt': 'application/vnd.ms-powerpoint',\r\n    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n    '.rar': 'application/x-rar-compressed',\r\n    '.srt': 'application/x-subrip',\r\n    '.svg': 'image/svg+xml',\r\n    '.swf': 'application/x-shockwave-flash',\r\n    '.ts': 'video/mp2t',\r\n    '.txt': 'text/plain',\r\n    '.wmv': 'video/x-ms-wmv',\r\n    '.xls': 'application/vnd.ms-excel',\r\n    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n    '.zip': 'application/zip',\r\n    '.mks': 'video/x-matroska',\r\n    '.mts': 'model/vnd.mts',\r\n    '.wma': 'audio/x-ms-wma'\r\n};\r\n\r\nexport function getMimeForExtension(extension: string = '', defaultType = 'video/mp4') {\r\n    extension = extension.toLowerCase();\r\n    if (extension && (extension in mimeTypes)) {\r\n        return mimeTypes[extension as keyof typeof mimeTypes];\r\n    }\r\n    return defaultType;\r\n}\r\n\r\nexport function getExtensionForMime(contentType: string, defaultExtension = '.mp4') {\r\n    const match = contentType && Object.entries(mimeTypes)\r\n        .find(([ext, mime]) => contentType.startsWith((mime)));\r\n    return match\r\n        ? match[0]\r\n        : defaultExtension;\r\n\r\n}\r\n\r\nfunction sanitizeFileUpload(payload: FileUploadPayloadInternal) {\r\n    let {\r\n        file,\r\n        options: {\r\n            filename = 'upload',\r\n            contentType = ''\r\n        }\r\n    } = payload;\r\n\r\n    // sanitize content type\r\n    if (contentType === 'application/octet-stream') {\r\n        contentType = '';\r\n    }\r\n    if (/charset/.test(contentType)) {\r\n        contentType = contentType.replace(/;?.*charset.*$/, '');\r\n    }\r\n    let name = filename.replace('\\.[^\\.]+$', '');\r\n    let ext = filename.replace(name, '');\r\n    if (!ext) {\r\n        ext = getExtensionForMime(contentType);\r\n    }\r\n    filename = `${name}${ext}`;\r\n    if (!contentType) {\r\n        contentType = getMimeForExtension(ext);\r\n    }\r\n    if (isBlobLike(file) && file.type !== contentType) {\r\n        payload.file = file.slice(0, file.size, contentType);\r\n    }\r\n    Object.assign(payload.options, {\r\n        filename,\r\n        contentType\r\n    });\r\n    return payload;\r\n}\r\n\r\nexport function appendJSONToForm(form: FormData, fieldName: string, data: any) {\r\n    form.append(fieldName, JSON.stringify(data));\r\n}\r\n\r\n/**\r\n * This method is included for isometric support of uploading files in node.js and browser.\r\n * @param form FormData instance\r\n * @param fieldName name of field to add to form\r\n * @param file the file. Can be Blob or File on browser. On node.js it can be anything the 'form-data' package will accept\r\n * @param options optional filename, contentType and contentLength of upload. Otherwise it will try to guess based on input\r\n */\r\nexport async function appendFileToForm(form: FormData, fieldName: string, file: FileUploadType, options: UploadFileOptions = { }): Promise<UploadFileOptions> {\r\n    const opts: UploadFileOptions = {\r\n        filename: 'upload',\r\n        contentType: '',\r\n        ...options\r\n    };\r\n    let payload = await polyfills.parseFileUpload(file, opts);\r\n    payload = sanitizeFileUpload(payload);\r\n    await polyfills.appendFileToForm(form, fieldName, payload);\r\n    return payload.options;\r\n}\r\n\r\nasync function prepareFileUploadHeaders(form: FormData, headers: Headers, useChunkedTransfer?: boolean) {\r\n    await polyfills.prepareUploadHeaders(form, headers, useChunkedTransfer);\r\n}\r\n\r\n/**\r\n * helper to upload multipart forms with files attached.\r\n * This is to work around issues with node.js's FormData implementation\r\n * @param rev Rev Client\r\n * @param method\r\n * @param endpoint\r\n * @param form\r\n * @param useChunkedTransfer\r\n * @param options\r\n * @returns\r\n */\r\nexport async function uploadMultipart(\r\n    rev: RevClient,\r\n    method: Rev.HTTPMethod,\r\n    endpoint: string,\r\n    form: FormData,\r\n    useChunkedTransfer: boolean | UploadFileOptions = false,\r\n    options: Rev.RequestOptions = { }\r\n) {\r\n    const {\r\n        headers: optHeaders\r\n    } = options;\r\n\r\n    useChunkedTransfer = typeof useChunkedTransfer === 'boolean'\r\n        ? useChunkedTransfer\r\n        : !!useChunkedTransfer?.useChunkedTransfer;\r\n\r\n    // coerce to Headers object, may be undefined\r\n    const headers = new polyfills.Headers(optHeaders);\r\n    // switches to transfer encoding upload if necessary\r\n    await prepareFileUploadHeaders(form, headers, useChunkedTransfer);\r\n\r\n    options.headers = headers;\r\n    const { body } = await rev.request(method, endpoint, form, options);\r\n    return body;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { Rev, Video } from '../types';\r\nimport { appendFileToForm, appendJSONToForm, FileUploadType, UploadFileOptions, uploadMultipart } from '../utils/file-utils';\r\nimport polyfills from '../interop';\r\n\r\n\r\nfunction splitOptions(options: UploadFileOptions) {\r\n    const {\r\n        signal,\r\n        ...uploadOptions\r\n    } = options;\r\n\r\n    return {\r\n        requestOptions: signal ? { signal } : {},\r\n        uploadOptions\r\n    };\r\n}\r\n\r\ntype PresentationChaptersOptions = Rev.RequestOptions & UploadFileOptions & {\r\n    contentType?: 'application/vnd.ms-powerpoint'\r\n                | 'application/vnd.openxmlformats-officedocument.presentationml.presentation';\r\n};\r\n\r\ntype TranscriptionOptions = Rev.RequestOptions & UploadFileOptions & {\r\n    contentType?: 'text/plain'\r\n                | 'application/x-subrip';\r\n};\r\n\r\ntype ChaptersOptions = Rev.RequestOptions & Omit<UploadFileOptions, 'filename' | 'contentLength'> & {\r\n    contentType?: 'application/x-7z-compressed'\r\n                | 'text/csv'\r\n                | 'application/msword'\r\n                | 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\r\n                | 'image/gif'\r\n                | 'image/jpeg'\r\n                | 'application/pdf'\r\n                | 'image/png'\r\n                | 'application/vnd.ms-powerpoint'\r\n                | 'application/vnd.openxmlformats-officedocument.presentationml.presentation'\r\n                | 'application/x-rar-compressed'\r\n                | 'image/svg+xml'\r\n                | 'text/plain'\r\n                | 'application/vnd.ms-excel'\r\n                | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\r\n                | 'application/zip'\r\n};\r\n\r\nexport default function uploadAPIFactory(rev: RevClient) {\r\n    const { FormData } = polyfills;\r\n\r\n\r\n\r\n    const uploadAPI = {\r\n        /**\r\n         * Upload a video, and returns the resulting video ID\r\n         */\r\n        async video(\r\n            file: FileUploadType,\r\n            metadata: Video.UploadMetadata = { uploader: rev.session.username ?? '' },\r\n            options: UploadFileOptions = {}): Promise<string> {\r\n\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            // prepare payload\r\n            const form = new FormData();\r\n\r\n            // at bare minimum the uploader needs to be defined\r\n            if (!metadata.uploader) {\r\n                // if using username login then uploader can be set to current user\r\n                const defaultUsername = rev.session.username;\r\n                if (defaultUsername) {\r\n                    metadata.uploader = defaultUsername;\r\n                } else {\r\n                    throw new TypeError('metadata must include uploader parameter');\r\n                }\r\n            }\r\n\r\n            // add video metadata to body (as json)\r\n            appendJSONToForm(form, 'video', metadata);\r\n\r\n            // append file (works around some node's form-data library quirks)\r\n            const filePayload = await appendFileToForm(form, 'VideoFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            const { videoId } = await uploadMultipart(rev, 'POST', '/api/v2/uploads/videos', form, filePayload, requestOptions);\r\n            return videoId;\r\n        },\r\n        async transcription(videoId: string, file: FileUploadType, language: Video.Transcription.SupportedLanguages = 'en', options: TranscriptionOptions = { }): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            // validate language\r\n            // TODO put this in a constants file somewhere\r\n            const supportedLanguages = ['de', 'en', 'en-gb', 'es-es', 'es-419', 'es', 'fr', 'fr-ca', 'id', 'it', 'ko', 'ja', 'nl', 'no', 'pl', 'pt', 'pt-br', 'th', 'tr', 'fi', 'sv', 'ru', 'el', 'zh', 'zh-tw', 'zh-cmn-hans'];\r\n\r\n            let lang = language.toLowerCase();\r\n            if (!supportedLanguages.includes(lang)) {\r\n                // try removing trailing language specifier\r\n                lang = lang.slice(2);\r\n                if (!supportedLanguages.includes(lang)) {\r\n                    throw new TypeError(`Invalid language ${language} - supported values are ${supportedLanguages.join(', ')}`);\r\n                }\r\n            }\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { language: lang, fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'TranscriptionFiles', metadata);\r\n\r\n            rev.log('info', `Uploading transcription to ${videoId} (${lang} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/transcription-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async supplementalFile(videoId: string, file: FileUploadType, options: Rev.RequestOptions & UploadFileOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'SupplementalFiles', metadata);\r\n\r\n            rev.log('info', `Uploading supplemental content to ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/supplemental-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        /**\r\n         *\r\n         * @param videoId id of video to add chapters to\r\n         * @param chapters list of chapters. Must have time value and one of title or imageFile\r\n         * @param action replace = POST/replace existing with this payload\r\n         *               append = PUT/add or edit without removing existing\r\n         * @param options  additional upload + request options\r\n         */\r\n        async chapters(videoId: string, chapters: Video.Chapter.Request[], action: 'append' | 'replace' = 'replace', options: ChaptersOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new FormData();\r\n\r\n            type ChapterPayload = Video.Chapter.Request & {imageFile?: string};\r\n\r\n            const metadata: {chapters: ChapterPayload[]} = {\r\n                chapters: []\r\n            };\r\n\r\n            for (let chapter of chapters) {\r\n                const {\r\n                    title, time, imageFile\r\n                } = chapter;\r\n\r\n                const chapterEntry: ChapterPayload = { time };\r\n                if (title) {\r\n                    chapterEntry.title = title;\r\n                }\r\n                if (imageFile) {\r\n                    const filePayload = await appendFileToForm(form, 'File', imageFile, uploadOptions);\r\n                    // add image filename based on what was appended to form\r\n                    chapterEntry.imageFile = filePayload.filename;\r\n                }\r\n            }\r\n\r\n            appendJSONToForm(form, 'Chapters', metadata);\r\n\r\n            rev.log('info', `${action === 'replace' ? 'Uploading' : 'Updating'} ${metadata.chapters.length} chapters to ${videoId}`);\r\n\r\n            const method = action === 'replace'\r\n                ? 'POST'\r\n                : 'PUT';\r\n\r\n            await uploadMultipart(rev, method, `/api/v2/uploads/chapters/${videoId}`, form, uploadOptions, requestOptions);\r\n        },\r\n        async thumbnail(videoId: string, file: FileUploadType, options: Rev.RequestOptions & UploadFileOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ThumbnailFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading thumbnail for ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/images/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async presentationChapters(videoId: string, file: FileUploadType, options: PresentationChaptersOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ThumbnailFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading thumbnail for ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/images/${videoId}`, form, filePayload, requestOptions);\r\n        }\r\n    };\r\n\r\n    return uploadAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, User } from '../types';\r\nimport { LiteralString } from '../types/rev';\r\nimport { isPlainObject } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nexport default function userAPIFactory(rev: RevClient) {\r\n    async function details(userId: string): Promise<User>;\r\n    async function details(username: string, type: 'username'): Promise<User>;\r\n    async function details(email: string, type: 'email'): Promise<User>;\r\n    async function details(userLookupValue: string, type?: User.DetailsLookup) {\r\n        const query = (type === 'username' || type === 'email')\r\n            ? { type }\r\n            : undefined;\r\n\r\n        return rev.get<User>(`/api/v2/users/${userLookupValue}`, query);\r\n    }\r\n\r\n    const userAPI = {\r\n        /**\r\n         * get the list of roles available in the system (with role name and id)\r\n         */\r\n        get roles() {\r\n            return rev.admin.roles;\r\n        },\r\n        /**\r\n         * Create a new User in Rev\r\n         * @param user\r\n         * @returns the User ID of the created user\r\n         */\r\n        async create(user: User.Request): Promise<string> {\r\n            const { userId } = await rev.post('/api/v2/users', user);\r\n            return userId;\r\n        },\r\n        async delete(userId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/users/${userId}`);\r\n        },\r\n        /**\r\n         * Get details about a specific user\r\n         * @param userLookupValue default is search by userId\r\n         * @param type            specify that userLookupValue is email or\r\n         *                        username instead of userId\r\n         * @returns {User}        User details\r\n         */\r\n        details,\r\n        /**\r\n         * get user details by username\r\n         * @deprecated - use details(username, 'username')\r\n         */\r\n        async getByUsername(username: string) {\r\n            // equivalent to rev.get<User>(`/api/v2/users/${username}`, { type: 'username' });\r\n            return userAPI.details(username, 'username');\r\n        },\r\n        /**\r\n         * get user details by email address\r\n         * @deprecated - use details(email, 'email')\r\n         */\r\n        async getByEmail(email: string) {\r\n            return userAPI.details(email, 'email');\r\n        },\r\n        /**\r\n         * Check if user exists in the system. Instead of throwing on a 401/403 error if\r\n         * user does not exist it returns false. Returns user details if does exist,\r\n         * instead of just true\r\n         * @param userLookupValue userId, username, or email\r\n         * @param type\r\n         * @returns User if exists, otherwise false\r\n         */\r\n        async exists(userLookupValue: string, type?: User.DetailsLookup): Promise<User | false> {\r\n            const query = (type === 'username' || type === 'email')\r\n            ? { type }\r\n            : undefined;\r\n\r\n            const response = await rev.request<User>('GET', `/api/v2/users/${userLookupValue}`, query, { responseType: 'json', throwHttpErrors: false });\r\n\r\n            return response.statusCode === 200\r\n                ? response.body\r\n                : false;\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async addToGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'add', path: '/GroupIds/-', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async removeFromGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'remove', path: '/GroupIds', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * search for users based on text query. Leave blank to return all users.\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.SearchOptions<User.SearchHit> = { }): SearchRequest<User.SearchHit> {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/search/access-entity',\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                /**\r\n                 * the result of this search is uppercase keys. This transforms them to camelcase to match other API responses\r\n                 */\r\n                transform: (items: User.RawSearchHit[]) => items.map(formatUserSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'user' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n         * Returns the channel and category subscriptions for the user making the API call.\r\n         */\r\n        async listSubscriptions(): Promise<{ categories: string[], channels: string[] }> {\r\n            return rev.get('/api/v2/users/subscriptions');\r\n        },\r\n        async subscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/subscribe', { id, type });\r\n        },\r\n        /**\r\n         * Unsubscribe from specific channel or category.\r\n         */\r\n        async unsubscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/unsubscribe', { id, type });\r\n        },\r\n        async getNotifications(unread: boolean = false): Promise<{ count: number, notifications: User.Notification[]}> {\r\n            return rev.get('/api/v2/users/notifications', { unread });\r\n        },\r\n        /**\r\n         *\r\n         * @param notificationId If notificationId not provided, then all notifications for the user are marked as read.\r\n         */\r\n        async markNotificationRead(notificationId?: string): Promise<void> {\r\n            await rev.put('/api/v2/users/notifications', notificationId ? {notificationId} : undefined);\r\n        }\r\n    };\r\n    return userAPI;\r\n}\r\n\r\nfunction formatUserSearchHit(hit: User.RawSearchHit): User.SearchHit {\r\n    return {\r\n        userId: hit.Id,\r\n        entityType: hit.EntityType,\r\n        email: hit.Email,\r\n        firstname: hit.FirstName,\r\n        lastname: hit.LastName,\r\n        username: hit.UserName\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, Video } from '../types';\r\nimport { asValidDate, isPlainObject } from '../utils';\r\nimport { IPageResponse, PagedRequest } from '../utils/paged-request';\r\n\r\n\r\nconst DEFAULT_INCREMENT: number = 30;\r\nconst DEFAULT_SORT: Rev.SortDirection = 'asc';\r\n\r\nfunction addDays(date: Date, numDays: number) {\r\n    const d = new Date(date.getTime());\r\n    d.setDate(d.getDate() + numDays);\r\n    return d;\r\n}\r\n\r\nfunction parseOptions(options: Video.VideoReportOptions) {\r\n    let {\r\n        incrementDays = DEFAULT_INCREMENT,\r\n        sortDirection = DEFAULT_SORT,\r\n        videoIds,\r\n        startDate,\r\n        endDate,\r\n        ...otherOptions\r\n    } = options;\r\n\r\n    // clamp increment to 1 minute - 30 days range\r\n    incrementDays = Math.min(\r\n        Math.max(\r\n            1 / 24 / 60,\r\n            parseFloat(incrementDays as any) || DEFAULT_INCREMENT\r\n        ),\r\n        30\r\n    );\r\n\r\n    // API expects videoIds as a string\r\n    if (Array.isArray(videoIds)) {\r\n        videoIds = videoIds\r\n            .map(s => s.trim())\r\n            .filter(Boolean)\r\n            .join(',');\r\n    }\r\n\r\n    return {\r\n        incrementDays, sortDirection, videoIds,\r\n        ...parseDates(startDate, endDate),\r\n        ...otherOptions\r\n    };\r\n}\r\n\r\nfunction parseDates(startArg: string | Date | undefined, endArg: string | Date | undefined) {\r\n    const now = new Date();\r\n    let startDate = asValidDate(startArg);\r\n    let endDate = asValidDate(endArg);\r\n\r\n    // if no end date set then use now, or startDate + 30 days\r\n    if (!endDate) {\r\n        if (startDate) {\r\n            endDate = addDays(startDate, 30);\r\n            if (endDate.getTime() > now.getTime()) {\r\n                endDate = now;\r\n            }\r\n        } else {\r\n            endDate = now;\r\n        }\r\n    }\r\n    // if no start/beginning date then use end - 30 days\r\n    if (!startDate)\r\n    {\r\n        startDate = addDays(endDate, -30);\r\n    }\r\n\r\n    // make sure times aren't swapped\r\n    if (startDate.getTime() > endDate.getTime()) {\r\n        [startDate, endDate] = [endDate, startDate];\r\n    }\r\n    return { startDate, endDate };\r\n}\r\n\r\nexport class VideoReportRequest extends PagedRequest<Video.VideoReportEntry> {\r\n    declare options: Required<ReturnType<typeof parseOptions>>;\r\n    private _rev: RevClient;\r\n    constructor(rev: RevClient, options: Video.VideoReportOptions = {}) {\r\n        super(parseOptions(options));\r\n\r\n        this._rev = rev;\r\n    }\r\n    protected async _requestPage() {\r\n        const { startDate, endDate } = this;\r\n        const {incrementDays, sortDirection, videoIds } = this.options;\r\n        const isAscending = sortDirection === 'asc';\r\n\r\n        let rangeStart = startDate;\r\n        let rangeEnd = endDate;\r\n        let done = false;\r\n\r\n        if (isAscending) {\r\n            rangeEnd = addDays(rangeStart, incrementDays);\r\n            //\r\n            if (rangeEnd >= endDate) {\r\n                done = true;\r\n                rangeEnd = endDate;\r\n            }\r\n        } else {\r\n            rangeStart = addDays(rangeEnd, -1 * incrementDays);\r\n            if (rangeStart <= startDate)\r\n            {\r\n                done = true;\r\n                rangeStart = startDate;\r\n            }\r\n        }\r\n\r\n        const query: Record<string, string> = {\r\n            after: rangeStart.toJSON(),\r\n            before: rangeEnd.toJSON()\r\n        };\r\n        if (videoIds) {\r\n            query.videoIds = videoIds;\r\n        }\r\n        const items: Video.VideoReportEntry[] = await this._rev.get(\"/api/v2/videos/report\", query, { responseType: \"json\" });\r\n\r\n        // go to next date range\r\n        if (!done) {\r\n            if (isAscending) {\r\n                this.startDate = rangeEnd;\r\n            } else {\r\n                this.endDate = rangeStart;\r\n            }\r\n        }\r\n\r\n        return {\r\n            items,\r\n            done\r\n        };\r\n    }\r\n    get startDate() { return this.options.startDate; }\r\n    set startDate(value) { this.options.startDate = value; }\r\n    get endDate() { return this.options.endDate; }\r\n    set endDate(value) { this.options.endDate = value; }\r\n}\r\n\r\nexport function videoReportAPI(rev: RevClient) {\r\n    function report(options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId: string, options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId?: string | Video.VideoReportOptions, options: Video.VideoReportOptions = {}): VideoReportRequest {\r\n        if (isPlainObject(videoId)) {\r\n            options = videoId;\r\n        } else if (typeof videoId === 'string') {\r\n            options = {\r\n                ...(options ?? {}),\r\n                videoIds: videoId\r\n            };\r\n        }\r\n        return new VideoReportRequest(rev, options);\r\n    }\r\n    return {\r\n        report\r\n    };\r\n}\r\n","import { Rev, Video } from \"../types\";\nimport { isPlainObject } from \"../utils\";\nimport type {RevClient} from \"../rev-client\";\n\n\nexport function videoDownloadAPI(rev: RevClient) {\n    /**\n     * Download a video. does not parse the output body. Note that content is sent as transfer-encoding: chunked;\n     * @param videoId\n     * @returns\n     */\n    async function download(videoId: string, options: Rev.RequestOptions = {}) {\n        const response = await rev.request<ReadableStream>('GET', `/api/v2/videos/${videoId}/download`, undefined, {\n            ...options,\n            responseType: 'stream'\n        });\n        return response;\n    }\n\n    /**\n     * download specified chapter. The chapter object has an imageUrl, this just wraps the functionality and adds the authorization header\n     * @param videoId\n     * @param chapter chapter object returned from the video.chapters(videoId) API call\n     * @returns\n     */\n    async function downloadChapter(chapter: Video.Chapter) {\n        const {imageUrl} = chapter;\n        const { body } = await rev.request<Blob>('GET', imageUrl, undefined, { responseType: 'blob' });\n        return body;\n    }\n\n    async function downloadSupplemental(file: Video.SupplementalFile): Promise<Blob>;\n    async function downloadSupplemental(videoId: string, fileId: string): Promise<Blob>;\n    async function downloadSupplemental(videoId: Video.SupplementalFile | string, fileId?: string) {\n        const endpoint = isPlainObject(videoId)\n            ? videoId.downloadUrl\n            : `/api/v2/videos/${videoId}/supplemental-files/${fileId}`;\n\n        const { body } = await rev.request<Blob>('GET', endpoint, undefined, { responseType: 'blob' });\n        return body;\n    }\n\n    async function downloadTranscription(transcription: Video.Transcription): Promise<Blob>;\n    async function downloadTranscription(videoId: string, language: string): Promise<Blob>;\n    async function downloadTranscription(videoId: Video.Transcription | string, language?: string) {\n        const endpoint = isPlainObject(videoId)\n            ? videoId.downloadUrl\n            : `/api/v2/videos/${videoId}/transcription-files/${language}`;\n\n        const { body } = await rev.request<Blob>('GET', endpoint, undefined, { responseType: 'blob' });\n        return body;\n    }\n\n    async function downloadThumbnail(thumbnailUrl: string): Promise<Blob>;\n    async function downloadThumbnail(query: { imageId: string }): Promise<Blob>;\n    async function downloadThumbnail(query: { videoId: string }): Promise<Blob>;\n    async function downloadThumbnail(query: string | { videoId?: string, imageId?: string; }) {\n        let {\n            videoId = '',\n            imageId = ''\n        } = typeof query === 'string'\n                ? { imageId: query }\n                : query;\n\n        if (!(videoId || imageId)) {\n            throw new TypeError('No video/image specified to download');\n        }\n\n        if (!imageId) {\n            // allow getting from api if only know the video ID\n            imageId = (await rev.get<{video: Video.Playback}>(`/api/v2/videos/${videoId}/playback-url`)).video.thumbnailUrl;\n        } else if (!imageId.endsWith('.jpg')) {\n            // make sure id has ending file extension\n            imageId = `${imageId}.jpg`;\n        }\n\n        let thumbnailUrl: string = imageId.startsWith('http')\n            ? imageId\n            : `/api/v2/media/videos/thumbnails/${imageId}.jpg`;\n\n        const { body } = await rev.request<Blob>('GET', thumbnailUrl, undefined, { responseType: 'blob' });\n        return body;\n    }\n\n    return {\n        download,\n        downloadChapter,\n        downloadSupplemental,\n        downloadThumbnail,\n        downloadTranscription\n    };\n}\n","import { RevError } from '../rev-error';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Video, Rev, Admin } from '../types';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { videoReportAPI } from './video-report-request';\r\nimport { videoDownloadAPI } from './video-download';\r\n\r\ntype VideoSearchDetailedItem = Video.SearchHit & (Video.Details | { error?: Error });\r\n\r\nexport default function videoAPIFactory(rev: RevClient) {\r\n    /** get list of comments on a video\r\n         * set showAll param to true to include un-redacted values of comments (admin only)\r\n         */\r\n    function comments(videoId: string): Promise<Video.Comment[]>;\r\n    function comments(videoId: string, showAll: true): Promise<Video.Comment.Unredacted[]>;\r\n    async function comments(videoId: string, showAll: boolean = false): Promise<Video.Comment[] | Video.Comment.Unredacted[]> {\r\n        const response = await rev.get<Video.Comment.ListResponse>(`/api/v2/videos/${videoId}/comments`, showAll ? { showAll: 'true' } : undefined);\r\n        return response.comments;\r\n    }\r\n    const videoAPI = {\r\n        /**\r\n         * This is an example of using the video Patch API to only update a single field\r\n         * @param videoId\r\n         * @param title\r\n         */\r\n        async setTitle(videoId: string, title: string) {\r\n            const payload = [{ op: 'add', path: '/Title', value: title }];\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        /**\r\n         * Use the Patch API to update a single Custom Field.\r\n         * @param videoId - id of video to update\r\n         * @param customField - the custom field object (with id and value)\r\n         */\r\n        async setCustomField(videoId: string, customField: Pick<Admin.CustomField, 'id' | 'value'>) {\r\n            const payload = [\r\n                { op: 'remove', path: '/customFields', value: customField.id },\r\n                { op: 'add', path: '/customFields/-', value: customField }\r\n            ];\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        /**\r\n         * get processing status of a video\r\n         * @param videoId\r\n         */\r\n        async status(videoId: string): Promise<Video.StatusResponse> {\r\n            return rev.get(`/api/v2/videos/${videoId}/status`);\r\n        },\r\n        async details(videoId: string): Promise<Video.Details> {\r\n            return rev.get(`/api/v2/videos/${videoId}/details`);\r\n        },\r\n        comments,\r\n        async chapters(videoId: string): Promise<Video.Chapter[]> {\r\n            try {\r\n                const {chapters} = await rev.get<{chapters: Video.Chapter[]}>(`/api/v2/videos/${videoId}/chapters`);\r\n                return chapters;\r\n            } catch (err) {\r\n                // if no chapters then this api returns a 400 response\r\n                if (err instanceof RevError && err.code === \"NoVideoChapters\") {\r\n                    return [];\r\n                }\r\n                throw err;\r\n            }\r\n        },\r\n        async supplementalFiles(videoId: string): Promise<Video.SupplementalFile[]> {\r\n            const {supplementalFiles} = await rev.get(`/api/v2/videos/${videoId}/supplemental-files`);\r\n            return supplementalFiles;\r\n        },\r\n        // async deleteSupplementalFiles(videoId: string, fileId: string | string[]): Promise<void> {\r\n        //     const fileIds = Array.isArray(fileId)\r\n        //         ? fileId.join(',')\r\n        //         : fileId\r\n        //     await rev.delete(`/api/v2/videos/${videoId}/supplemental-files`, { fileIds });\r\n        // },\r\n        async transcriptions(videoId: string): Promise<Video.Transcription[]> {\r\n            const {transcriptionFiles} = await rev.get(`/api/v2/videos/${videoId}/transcription-files`);\r\n            return transcriptionFiles;\r\n        },\r\n        get upload() {\r\n            return rev.upload.video;\r\n        },\r\n        async migrate(videoId: string, options: Video.MigrateRequest) {\r\n            await rev.put(`/api/v2/videos/${videoId}/migration`, options);\r\n        },\r\n        /**\r\n         * search for videos, return as one big list. leave blank to get all videos in the account\r\n         */\r\n        search(query: Video.SearchOptions = { }, options: Rev.SearchOptions<Video.SearchHit> = { }): Rev.ISearchRequest<Video.SearchHit> {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos'\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        /**\r\n         * Example of using the video search API to search for videos, then getting\r\n         * the details of each video\r\n         * @param query\r\n         * @param options\r\n         */\r\n        searchDetailed(\r\n            query: Video.SearchOptions = { },\r\n            options: Rev.SearchOptions<VideoSearchDetailedItem> = { }\r\n        ): Rev.ISearchRequest<VideoSearchDetailedItem> {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos',\r\n                transform: async (videos: Video.SearchHit[]) => {\r\n                    const result = [];\r\n                    for (let rawVideo of videos) {\r\n                        const out: Video.SearchHit & (Video.Details & { error?: Error; }) = rawVideo as any;\r\n                        try {\r\n                            const details = await videoAPI.details(rawVideo.id);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        async playbackInfo(videoId: string): Promise<Video.Playback> {\r\n            const { video } = await rev.get(`/api/v2/videos/${videoId}/playback-url`);\r\n            return video;\r\n        },\r\n        ...videoDownloadAPI(rev),\r\n        ...videoReportAPI(rev),\r\n        async trim(videoId: string, removedSegments: Array<{ start: string, end: string }>) {\r\n            return rev.post(`/api/v2/videos/${videoId}/trim`, removedSegments);\r\n        }\r\n    };\r\n    return videoAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types';\r\nimport { Webcast } from '../types/webcast';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nfunction getSummaryFromResponse<T extends Record<string, any>>(response: T, hitsKey: string) {\r\n    const ignoreKeys = ['scrollId', 'statusCode', 'statusDescription'];\r\n\r\n    const summary = Object.fromEntries(Object.entries(response)\r\n        .filter(([key, value]) => {\r\n            // don't include arrays or scroll type keys\r\n            return !(key === hitsKey || ignoreKeys.includes(key) || Array.isArray(value));\r\n        }));\r\n    return summary;\r\n}\r\n\r\nexport class RealtimeReportRequest<T extends Webcast.RealtimeSession = Webcast.RealtimeSession> extends SearchRequest<T> {\r\n    declare summary: Webcast.RealtimeSummary;\r\n    constructor(rev: RevClient, eventId: string, query: Webcast.RealtimeRequest = {}, options: Rev.SearchOptions<T> = {}) {\r\n        const searchDefinition: Rev.SearchDefinition<T> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/real-time/attendees`,\r\n            totalKey: 'total',\r\n            hitsKey: 'attendees',\r\n            // get summary from initial response\r\n            request: async (endpoint, query, options) => {\r\n                const response = await rev.post<Webcast.RealtimeSummary>(endpoint, query, options);\r\n\r\n                const summary = getSummaryFromResponse(response, 'attendees');\r\n                Object.assign(this.summary, summary);\r\n                return response;\r\n            }\r\n        };\r\n        super(rev, searchDefinition, query, options);\r\n        this.summary = {} as any;\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n\r\nexport class PostEventReportRequest extends SearchRequest<Webcast.PostEventSession> {\r\n    declare summary: Webcast.PostEventSummary;\r\n    constructor(rev: RevClient, query: { eventId: string, runNumber?: number }, options: Rev.SearchOptions<Webcast.PostEventSession> = {}) {\r\n        const { eventId, runNumber } = query;\r\n        const runQuery = (runNumber && runNumber >= 0)\r\n            ? { runNumber }\r\n            : {};\r\n\r\n        const searchDefinition: Rev.SearchDefinition<Webcast.PostEventSession> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/post-event-report`,\r\n                totalKey: 'totalSessions',\r\n                hitsKey: 'sessions',\r\n                request: async (endpoint, query, options) => {\r\n                    const response = await rev.get<Webcast.PostEventSummary>(endpoint, query, options);\r\n\r\n                    const summary = getSummaryFromResponse(response, 'sessions');\r\n                    Object.assign(this.summary, summary);\r\n                    return response;\r\n                }\r\n        };\r\n        super(rev, searchDefinition,  runQuery, options);\r\n        this.summary = {};\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n","import { Rev } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Webcast, GuestRegistration } from '../types/webcast';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { titleCase } from '../utils';\r\nimport { PostEventReportRequest, RealtimeReportRequest } from './webcast-report-request';\r\n\r\ntype RealtimeSession<T extends Webcast.RealtimeRequest | undefined> = T extends { attendeeDetails: 'All' }\r\n    ? Webcast.RealtimeSessionDetail\r\n    : T extends { attendeeDetails: 'Counts' }\r\n    ? never\r\n    : Webcast.RealtimeSession;\r\n\r\nexport default function webcastAPIFactory(rev: RevClient) {\r\n    const webcastAPI = {\r\n        async list(options: Webcast.ListRequest = { }): Promise<Webcast[]> {\r\n            return rev.get('/api/v2/scheduled-events', options, { responseType: 'json' });\r\n        },\r\n        search(query: Webcast.SearchRequest, options?: Rev.SearchOptions<Webcast>): SearchRequest<Webcast> {\r\n            const searchDefinition: Rev.SearchDefinition<Webcast> = {\r\n                endpoint: `/api/v2/search/scheduled-events`,\r\n                totalKey: 'total',\r\n                hitsKey: 'events',\r\n                request: (endpoint, query, options) => rev.post(endpoint, query, options),\r\n                isPost: true\r\n            };\r\n            return new SearchRequest<Webcast>(rev, searchDefinition, query, options);\r\n        },\r\n        async create(event: Webcast.CreateRequest): Promise<string> {\r\n            const { eventId } = await rev.post(`/api/v2/scheduled-events`, event);\r\n            return eventId;\r\n        },\r\n        async details(eventId: string): Promise<Webcast.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}`);\r\n        },\r\n        async edit(eventId: string, event: Webcast.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}`, event);\r\n        },\r\n        // async patch - not yet implemented\r\n        async delete(eventId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}`);\r\n        },\r\n        async editAccess(eventId: string, entities: Webcast.EditAttendeesRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/access-control`, entities);\r\n        },\r\n        attendees(\r\n            eventId: string,\r\n            runNumber?: number,\r\n            options?: Rev.SearchOptions<Webcast.PostEventSession>\r\n        ) {\r\n            return new PostEventReportRequest(rev, { eventId, runNumber }, options);\r\n        },\r\n        realtimeAttendees<T extends Webcast.RealtimeRequest | undefined>(\r\n            eventId: string,\r\n            query?: T,\r\n            options?: Rev.SearchOptions<RealtimeSession<T>>\r\n        ) {\r\n            return new RealtimeReportRequest<RealtimeSession<T>>(rev, eventId, query, options);\r\n        },\r\n        async questions(eventId: string, runNumber?: number): Promise<Webcast.Question[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/questions`, query, { responseType: 'json' });\r\n        },\r\n        async pollResults(eventId: string, runNumber?: number): Promise<Webcast.PollResults[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/poll-results`, query, { responseType: 'json' });\r\n        },\r\n        async comments(eventId: string, runNumber?: number): Promise<Webcast.Comment[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/comments`, query, { responseType: 'json' });\r\n        },\r\n        async status(eventId: string): Promise<Webcast.Status> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/status`);\r\n        },\r\n        async playbackUrl(eventId: string, options: Webcast.PlaybackUrlRequest = { }): Promise<Webcast.Playback[]> {\r\n            const {\r\n                ip,\r\n                userAgent\r\n            } = options;\r\n\r\n            const query = ip ? { ip } : undefined;\r\n\r\n            const requestOptions: Rev.RequestOptions = {\r\n                responseType: 'json'\r\n            };\r\n            if (userAgent) {\r\n                requestOptions.headers = { 'User-Agent': userAgent };\r\n            }\r\n\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/playback-url`, query, requestOptions);\r\n        },\r\n        async startEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async stopEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async startBroadcast(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async stopBroadcast(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async startRecord(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async stopRecord(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async linkVideo(eventId: string, videoId: string, autoRedirect: boolean = true) {\r\n            const payload = {\r\n                videoId,\r\n                redirectVod: autoRedirect\r\n            };\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/linked-video`, payload);\r\n        },\r\n        async unlinkVideo(eventId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/linked-video`);\r\n        },\r\n        /**\r\n         * Retrieve details of a specific guest user Public webcast registration.\r\n         * @param eventId - Id of the Public webcast\r\n         * @param registrationId - Id of guest user's registration to retrieve\r\n         * @returns\r\n         */\r\n        async guestRegistration(eventId: string, registrationId: string): Promise<GuestRegistration.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n        /**\r\n         * Register one attendee/guest user for an upcoming Public webcast. Make sure you first enable Public webcast pre-registration before adding registrations.\r\n         * @param eventId\r\n         * @param registration\r\n         * @returns\r\n         */\r\n        async createGuestRegistration(eventId: string, registration: GuestRegistration.Request): Promise<GuestRegistration.Details> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/registrations`, registration);\r\n        },\r\n        listGuestRegistrations(\r\n            eventId: string,\r\n            query: GuestRegistration.SearchRequest = {},\r\n            options?: Rev.SearchOptions<GuestRegistration>\r\n        ): SearchRequest<GuestRegistration> {\r\n            const searchDefinition: Rev.SearchDefinition<GuestRegistration> = {\r\n                endpoint: `/api/v2/scheduled-events/${eventId}/registrations`,\r\n                /** NOTE: this API doesn't actually return a total, so this will always be undefined */\r\n                totalKey: 'total',\r\n                hitsKey: 'guestUsers'\r\n            };\r\n            return new SearchRequest<GuestRegistration>(rev, searchDefinition, query, options);\r\n        },\r\n        updateGuestRegistration(eventId: string, registrationId: string, registration: GuestRegistration.Request): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, registration);\r\n        },\r\n        patchGuestRegistration(eventId: string, registrationId: string, registration: Partial<GuestRegistration.Request>): Promise<void> {\r\n            const operations = Object.entries(registration)\r\n                .map(([key, value]) => {\r\n                    let path = `/${titleCase(key)}`;\r\n                    return { op: 'replace', path, value };\r\n                });\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, operations);\r\n        },\r\n        deleteGuestRegistration(eventId: string, registrationId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n\r\n    };\r\n\r\n    return webcastAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { Zone } from '../types/zone';\r\n\r\nexport default function zonesAPIFactory(rev: RevClient) {\r\n    const zonesAPI = {\r\n        async list(): Promise<{ defaultZone: Zone, zones: Zone[]; }> {\r\n            return rev.get(`/api/v2/zones`, undefined, { responseType: 'json' });\r\n        },\r\n        async flatList(): Promise<Zone.FlatZone[]> {\r\n            const {\r\n                defaultZone,\r\n                zones\r\n            } = await zonesAPI.list();\r\n            const flatZones: Omit<Zone, 'childZones'>[] = [defaultZone];\r\n            function recursiveAdd(inZone: Zone) {\r\n                const {\r\n                    childZones = [],\r\n                    ...zone\r\n                } = inZone;\r\n\r\n                flatZones.push(zone);\r\n                childZones.forEach(recursiveAdd);\r\n            }\r\n            zones.forEach(recursiveAdd);\r\n            return flatZones;\r\n        },\r\n        async create(zone: Zone.CreateRequest): Promise<string> {\r\n            const { zoneId } = await rev.post(`/api/v2/zones`, zone, { responseType: 'json' });\r\n            return zoneId;\r\n        },\r\n        async edit(zoneId: string, zone: Zone.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/zones/${zoneId}`, zone);\r\n        },\r\n        delete(zoneId: string) {\r\n            return rev.delete(`/api/v2/zones/${zoneId}`);\r\n        },\r\n        get devices() {\r\n            return rev.device.listZoneDevices;\r\n        }\r\n    };\r\n    return zonesAPI;\r\n}\r\n","import type { RevClient } from './rev-client';\r\nimport type { Rev } from './types';\r\nimport { isPlainObject, sleep } from './utils';\r\nimport interop from './interop';\r\n\r\nconst ONE_MINUTE = 1000 * 60;\r\n\r\n// obsfucate credentials to avoid accidental disclosure\r\nconst _credentials = Symbol('credentials');\r\n\r\ninterface LoginResponse {\r\n    token: string,\r\n    expiration: string,\r\n    userId?: string,\r\n    refreshToken?: string,\r\n    apiKey?: string;\r\n}\r\n\r\nclass SessionKeepAlive {\r\n    private readonly _session!: SessionBase;\r\n    private controller?: AbortController;\r\n    extendOptions: Required<Rev.KeepAliveOptions>;\r\n    error?: undefined | Error;\r\n    private _isExtending: boolean = false;\r\n    constructor(session: SessionBase, options: Rev.KeepAliveOptions = { }) {\r\n        // TODO verify values?\r\n        this.extendOptions = {\r\n            extendThresholdMilliseconds: 3 * ONE_MINUTE,\r\n            keepAliveInterval: 5 * ONE_MINUTE,\r\n            verify: true,\r\n            ...options\r\n        };\r\n\r\n        Object.defineProperties(this, {\r\n            _session: {\r\n                get: () => session,\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    getNextExtendTime() {\r\n        const { expires } = this._session;\r\n        if (!expires) {\r\n            return 0;\r\n        }\r\n        const {\r\n            keepAliveInterval: interval,\r\n            extendThresholdMilliseconds: threshold\r\n        } = this.extendOptions;\r\n\r\n        const timeTillExpiration = expires.getTime() - Date.now();\r\n        // clamp range to within 0 and max interval\r\n        return Math.max(0, Math.min(timeTillExpiration - threshold, interval));\r\n    }\r\n    private async _poll() {\r\n        const { _session: session } = this;\r\n        // force stop other poll process if already polling\r\n        // keep reference to controller in case of reset\r\n        const controller = this._reset();\r\n        const { signal } = controller;\r\n\r\n        while (session.isConnected && !signal.aborted) {\r\n            const nextExtendTime = this.getNextExtendTime();\r\n            await sleep(nextExtendTime, signal);\r\n\r\n            // check if poll was aborted. if so don't try to extend\r\n            if (signal.aborted) {\r\n                break;\r\n            }\r\n\r\n            // extend session\r\n            // possible this can throw an error\r\n            try {\r\n                // extending may re-login, so pause poll resets for now\r\n                this._isExtending = true;\r\n                await session.lazyExtend(this.extendOptions);\r\n            } catch (err: any) {\r\n                // swallow error, but signal stopped using abort controller\r\n                controller.abort();\r\n                this.error = err;\r\n            } finally {\r\n                this._isExtending = false;\r\n            }\r\n        }\r\n    }\r\n    start() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        this._poll();\r\n    }\r\n    stop() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        if (this.controller) {\r\n            this.controller.abort();\r\n        }\r\n    }\r\n    private _reset() {\r\n        this.error = undefined;\r\n        this._isExtending = false;\r\n        const oldController = this.controller;\r\n        this.controller = new interop.AbortController();\r\n\r\n        // stop previous poll\r\n        if (oldController) {\r\n            oldController.abort();\r\n        }\r\n        return this.controller;\r\n    }\r\n    get isAlive() {\r\n        return this.controller && !this.controller.signal.aborted;\r\n    }\r\n}\r\n\r\nabstract class SessionBase implements Rev.IRevSession {\r\n    token?: string;\r\n    expires: Date;\r\n    protected readonly rev!: RevClient;\r\n    protected readonly [_credentials]!: Rev.Credentials;\r\n    readonly keepAlive?: SessionKeepAlive;\r\n    constructor(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions) {\r\n        this.expires = new Date();\r\n\r\n        if (keepAliveOptions === true) {\r\n            this.keepAlive = new SessionKeepAlive(this);\r\n        } else if (isPlainObject(keepAliveOptions)) {\r\n            this.keepAlive = new SessionKeepAlive(this, keepAliveOptions);\r\n        }\r\n\r\n        // add as private member\r\n        Object.defineProperties(this, {\r\n            rev: {\r\n                get() { return rev; },\r\n                enumerable: false\r\n            },\r\n            [_credentials]: {\r\n                get() { return credentials; },\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    async login() {\r\n        this.token = undefined;\r\n        this.expires = new Date();\r\n\r\n        const {\r\n            expiration,\r\n            ...session\r\n        } = await this._login();\r\n\r\n        Object.assign(this, session);\r\n\r\n        const expires = new Date(expiration);\r\n        // VERY edge case where old date could be returned - just assume 10 min expiration\r\n        if (expires.getTime() < this.expires.getTime()) {\r\n            this.expires.setUTCMinutes(this.expires.getUTCMinutes() + 10);\r\n        } else {\r\n            this.expires = expires;\r\n        }\r\n\r\n        if (this.keepAlive) {\r\n            this.keepAlive.start();\r\n        }\r\n    }\r\n    async extend() {\r\n        const { expiration } = await this._extend();\r\n        this.expires = new Date(expiration);\r\n    }\r\n    async logoff() {\r\n        if (this.keepAlive) {\r\n            this.keepAlive.stop();\r\n        }\r\n        try {\r\n            await this._logoff();\r\n        } finally {\r\n            this.token = undefined;\r\n            this.expires = new Date();\r\n        }\r\n    }\r\n    async verify() {\r\n        try {\r\n            await this.rev.auth.verifySession();\r\n            return true;\r\n        } catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @returns wasExtended - whether session was extended / re-logged in\r\n     */\r\n    async lazyExtend(options: Rev.KeepAliveOptions = { }) {\r\n        const {\r\n            extendThresholdMilliseconds: threshold = 3 * ONE_MINUTE,\r\n            verify: shouldVerify = true\r\n        } = options;\r\n\r\n        const { expires } = this;\r\n        const timeLeft = expires\r\n            ? expires.getTime() - Date.now()\r\n            : -1;\r\n\r\n        // login if session expired\r\n        if (timeLeft <= 0) {\r\n            await this.login();\r\n            return true;\r\n        }\r\n\r\n        // extend if within extend window\r\n        if (timeLeft > threshold) {\r\n            try {\r\n                await this.extend();\r\n                // successful extend, nothing more to do\r\n                return true;\r\n            } catch (error) {\r\n                this.rev.log('warn', 'Error extending session - re-logging in', error);\r\n            }\r\n            // check if valid session if plenty of time left\r\n        } else if (!shouldVerify || await this.verify()) {\r\n            // valid, no change\r\n            return false;\r\n        }\r\n\r\n        // if reached here then need to re-login\r\n        await this.login();\r\n        return true;\r\n    }\r\n    /**\r\n     * check if expiration time of session has passed\r\n     */\r\n    get isExpired() {\r\n        const { expires } = this;\r\n        if (!expires) {\r\n            return true;\r\n        }\r\n        return Date.now() > expires.getTime();\r\n    }\r\n    /**\r\n     * returns true if session isn't expired and has a token\r\n     */\r\n    get isConnected() {\r\n        return !!this.token && !this.isExpired;\r\n    }\r\n    get username() {\r\n        return this[_credentials].username;\r\n    }\r\n    protected abstract _login(): Promise<LoginResponse>;\r\n    protected abstract _extend(): Promise<{ expiration: string; }>;\r\n    protected abstract _logoff(): Promise<void>;\r\n    public abstract toJSON(): Rev.IRevSessionState;\r\n}\r\n\r\n/**\r\n * Use OAuth2Session instead if possible\r\n * @deprecated\r\n */\r\nexport class OAuthSession extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, authCode } = this[_credentials];\r\n        if (!oauthConfig || !authCode) {\r\n            throw new TypeError('OAuth Config / auth code not specified');\r\n        }\r\n        const {\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth(oauthConfig, authCode);\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        const { [_credentials]: { oauthConfig } } = this;\r\n\r\n        const {\r\n            // other API calls call this \"token\" instead of \"accessToken\", hence the rename\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken\r\n        } = await this.rev.auth.extendSessionOAuth(oauthConfig as any, <string>this.refreshToken);\r\n\r\n        // unlike other extend methods this updates the token + refreshToken each time\r\n        Object.assign(this, { token, refreshToken });\r\n        return { expiration };\r\n    }\r\n    async _logoff() {\r\n        // nothing to do\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            refreshToken: this.refreshToken\r\n        };\r\n    }\r\n}\r\n\r\nexport class OAuth2Session extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, code, codeVerifier } = this[_credentials];\r\n        if (!oauthConfig || !code || !codeVerifier) {\r\n            throw new TypeError('OAuth Config / auth code / verifier not specified');\r\n        }\r\n        const {\r\n            access_token: token,\r\n            expires_in,\r\n            refresh_token: refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth2(oauthConfig, code, codeVerifier);\r\n        const expiresTime = Date.now() + parseInt(expires_in, 10) * 1000;\r\n        const expiration = new Date(expiresTime).toISOString();\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class UserSession extends SessionBase {\r\n    userId?: string;\r\n    async _login() {\r\n        const { username, password } = this[_credentials];\r\n        if (!username || !password) {\r\n            throw new TypeError('username/password not specified');\r\n        }\r\n        const {\r\n            token,\r\n            expiration,\r\n            id: userId\r\n        } = await this.rev.auth.loginUser(username, password);\r\n        return { token, expiration, userId };\r\n    }\r\n    async _extend() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.extendSessionUser(<string>userId);\r\n    }\r\n    async _logoff() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.logoffUser(<string>userId);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            userId: this.userId\r\n        };\r\n    }\r\n}\r\n\r\nexport class ApiKeySession extends SessionBase {\r\n    async _login() {\r\n        const { apiKey, secret } = this[_credentials];\r\n        if (!apiKey || !secret) {\r\n            throw new TypeError('apiKey/secret not specified');\r\n        }\r\n        return this.rev.auth.loginToken(apiKey, secret);\r\n    }\r\n    async _extend() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.extendSessionToken(<string>apiKey);\r\n    }\r\n    async _logoff() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.logoffToken(<string>apiKey);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            apiKey: this[_credentials].apiKey\r\n        };\r\n    }\r\n}\r\n\r\nexport class JWTSession extends SessionBase {\r\n    async _login() {\r\n        const { jwtToken } = this[_credentials];\r\n        if (!jwtToken) {\r\n            throw new TypeError('JWT Token not specified');\r\n        }\r\n        const {accessToken: token, expiration} = await this.rev.auth.loginJWT(jwtToken);\r\n        return { token, expiration, issuer: 'vbrick' };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class AccessTokenSession extends SessionBase {\r\n    // just verify user on login\r\n    async _login() {\r\n        await this.rev.auth.verifySession();\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires?.toISOString(),\r\n            issuer: 'vbrick'\r\n        };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport function createSession(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions) {\r\n    let session: Rev.IRevSession;\r\n\r\n    const {\r\n        session: sessionState = {} as Rev.IRevSessionState,\r\n        ...creds\r\n    } = credentials;\r\n\r\n    const {\r\n        token,\r\n        expiration,\r\n        refreshToken,\r\n        userId\r\n    } = sessionState;\r\n\r\n    const now = Date.now();\r\n    const expires = new Date(expiration || now);\r\n    const hasSession = (token && typeof token === 'string') && (expires.getTime() > now);\r\n\r\n    const isOAuth2Login = credentials.oauthConfig && (credentials.code && credentials.codeVerifier);\r\n    const isLegacyOauthLogin = credentials.oauthConfig && (credentials.authCode || (hasSession && refreshToken));\r\n    const isApiKeyLogin = credentials.apiKey && (credentials.secret || (hasSession && !userId));\r\n    const isUsernameLogin = credentials.username && (credentials.password || (hasSession && userId));\r\n    const isJWTLogin = credentials.jwtToken;\r\n\r\n    // prefer oauth first, then apikey then username if multiple params specified\r\n    if (isOAuth2Login) {\r\n        session = new OAuth2Session(rev, creds, keepAliveOptions);\r\n    } else if (isLegacyOauthLogin) {\r\n        session = new OAuthSession(rev, creds, keepAliveOptions);\r\n        if (refreshToken) {\r\n            (session as OAuthSession).refreshToken = refreshToken;\r\n        }\r\n    } else if (isApiKeyLogin) {\r\n        session = new ApiKeySession(rev, creds, keepAliveOptions);\r\n    } else if (isJWTLogin) {\r\n        session = new JWTSession(rev, creds, keepAliveOptions);\r\n    } else if (isUsernameLogin) {\r\n        session = new UserSession(rev, creds, keepAliveOptions);\r\n        if (userId) {\r\n            (session as UserSession).userId = userId;\r\n        }\r\n    } else if (hasSession) {\r\n        session = new AccessTokenSession(rev, creds, keepAliveOptions);\r\n    } else {\r\n        throw new TypeError('Must specify credentials (username+password, apiKey+secret or oauthConfig+authCode)');\r\n    }\r\n\r\n    if (hasSession) {\r\n        session.token = token;\r\n        session.expires = expires;\r\n    }\r\n    return session;\r\n}\r\n","import { RevError } from './rev-error';\r\nimport { isPlainObject, retry } from './utils';\r\nimport * as api from './api';\r\nimport polyfills from './interop';\r\nimport { Rev } from './types';\r\nimport { decodeBody } from './utils/request-utils';\r\nimport { createSession } from './rev-session';\r\n\r\ntype PayloadType = { [key: string]: any; } | Record<string, any> | any[];\r\n\r\nexport class RevClient {\r\n    url: string;\r\n    logEnabled: boolean;\r\n    session: Rev.IRevSession;\r\n    readonly admin!: ReturnType<typeof api.admin>;\r\n    readonly audit!: ReturnType<typeof api.audit>;\r\n    readonly auth!: ReturnType<typeof api.auth>;\r\n    readonly category!: ReturnType<typeof api.category>;\r\n    readonly channel!: ReturnType<typeof api.channel>;\r\n    readonly device!: ReturnType<typeof api.device>;\r\n    readonly group!: ReturnType<typeof api.group>;\r\n    readonly playlist!: ReturnType<typeof api.playlist>;\r\n    readonly recording!: ReturnType<typeof api.recording>;\r\n    readonly upload!: ReturnType<typeof api.upload>;\r\n    readonly user!: ReturnType<typeof api.user>;\r\n    readonly video!: ReturnType<typeof api.video>;\r\n    readonly webcast!: ReturnType<typeof api.webcast>;\r\n    readonly zones!: ReturnType<typeof api.zones>;\r\n    constructor(options: Rev.Options) {\r\n        if (!isPlainObject(options) || !options.url) {\r\n            throw new TypeError('Missing configuration options for client - url and username/password or apiKey/secret');\r\n        }\r\n        const {\r\n            url,\r\n            log,\r\n            logEnabled = false,\r\n            keepAlive = true,\r\n            ...credentials\r\n        } = options;\r\n\r\n        // get just the origin of provided url\r\n        const urlObj = new URL(url);\r\n        this.url = urlObj.origin;\r\n\r\n        // will throw error if credentials are invalid\r\n        this.session = createSession(this, credentials, keepAlive);\r\n\r\n        // add logging functionality\r\n        this.logEnabled = !!logEnabled;\r\n        if (log) {\r\n            this.log = (severity: Rev.LogSeverity, ...args: any[]) => {\r\n                if (!this.logEnabled) {\r\n                    return;\r\n                }\r\n                log(severity, ...args);\r\n            };\r\n        }\r\n\r\n        // add all API endpoints\r\n        Object.defineProperties(this, {\r\n            admin: { value: api.admin(this), writable: false },\r\n            audit: { value: api.audit(this), writable: false },\r\n            auth: { value: api.auth(this), writable: false },\r\n            category: { value: api.category(this), writable: false },\r\n            channel: { value: api.channel(this), writable: false },\r\n            device: { value: api.device(this), writable: false },\r\n            group: { value: api.group(this), writable: false },\r\n            playlist: { value: api.playlist(this), writable: false },\r\n            recording: { value: api.recording(this), writable: false },\r\n            upload: { value: api.upload(this), writable: false },\r\n            user: { value: api.user(this), writable: false },\r\n            video: { value: api.video(this), writable: false },\r\n            webcast: { value: api.webcast(this), writable: false },\r\n            // COMBAK - DEPRECATED\r\n            webcasts: { get: () => {\r\n                this.log('debug', 'webcasts is deprecated - use rev.webcast instead');\r\n                return this.webcast;\r\n            }, enumerable: false },\r\n            zones: { value: api.zones(this), writable: false }\r\n        });\r\n    }\r\n    /**\r\n     * make a REST request\r\n     */\r\n    async request<T = any>(method: Rev.HTTPMethod, endpoint: string, data: any = undefined, options: Rev.RequestOptions = { }): Promise<Rev.Response<T>> {\r\n        const url = new URL(endpoint, this.url);\r\n        // ensure url matches Rev url, to avoid sending authorization header elsewhere\r\n        if (url.origin !== this.url) {\r\n            throw new TypeError(`Invalid endpoint - must be relative to ${this.url}`);\r\n        }\r\n\r\n        let {\r\n            headers: optHeaders,\r\n            responseType,\r\n            throwHttpErrors = true,\r\n            ...requestOpts\r\n        } = options;\r\n\r\n        // setup headers for JSON communication (by default)\r\n        const headers = new polyfills.Headers(optHeaders);\r\n\r\n        // add authorization header from stored token\r\n        if (this.session.token && !headers.has('Authorization')) {\r\n            headers.set('Authorization', `VBrick ${this.session.token}`);\r\n        }\r\n        if (headers.get('Authorization') === '') {\r\n            // if Auth is explicitly set to '' then remove from list\r\n            headers.delete('Authorization');\r\n        }\r\n\r\n        const fetchOptions: RequestInit = {\r\n            mode: 'cors',\r\n            method,\r\n            ...requestOpts,\r\n            headers\r\n        };\r\n\r\n        // default to JSON request payload, but allow it to be overridden\r\n        let shouldSetAsJSON = !headers.has('Content-Type');\r\n\r\n        // add provided data to request body or as query string parameters\r\n\r\n        if (data) {\r\n            if (['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {\r\n                if (typeof data === 'string') {\r\n                    fetchOptions.body = data;\r\n                } else if (data instanceof polyfills.FormData) {\r\n                    shouldSetAsJSON = false;\r\n                    fetchOptions.body = data;\r\n                } else if (isPlainObject(data) || Array.isArray(data)) {\r\n                    fetchOptions.body = JSON.stringify(data);\r\n                } else {\r\n                    fetchOptions.body = data;\r\n                }\r\n            } else if (isPlainObject(data)) {\r\n                // add values to query string of URL\r\n                for (let [key, value] of Object.entries(data)) {\r\n                    url.searchParams.append(key, value);\r\n                }\r\n            } else {\r\n                throw new TypeError(`Invalid payload for request to ${method} ${endpoint}`);\r\n            }\r\n        }\r\n\r\n        // default to JSON communication\r\n        if (!headers.has('Accept')) {\r\n            headers.set('Accept', 'application/json');\r\n        }\r\n        // set to JSON payload\r\n        if (shouldSetAsJSON) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n\r\n        // OPTIONAL log request and response\r\n        this.log('debug', `Request ${method} ${endpoint}`);\r\n\r\n        // NOTE: will throw error on AbortError or client fetch errors\r\n        const response = await polyfills.fetch(`${url}`, {\r\n            ...fetchOptions,\r\n            method,\r\n            headers\r\n        });\r\n\r\n        const {\r\n            ok,\r\n            status: statusCode,\r\n            statusText,\r\n            headers: responseHeaders\r\n        } = response;\r\n\r\n        this.log('debug', `Response ${method} ${endpoint} ${statusCode} ${statusText}`);\r\n\r\n        // check for error response code\r\n        if (!ok) {\r\n            if (throwHttpErrors) {\r\n                const err = await RevError.create(response);\r\n                throw err;\r\n            }\r\n            // if not throwwing then force responseType to auto (could be text or json)\r\n            responseType = undefined;\r\n        }\r\n\r\n        let body: any = response.body;\r\n\r\n        switch (responseType) {\r\n            case 'json':\r\n                body = await response.json();\r\n                break;\r\n            case 'text':\r\n                body = await response.text();\r\n                break;\r\n            case 'blob':\r\n                body = await response.blob();\r\n                break;\r\n            case 'stream':\r\n                body = response.body;\r\n                break;\r\n            default:\r\n                // if no mimetype in response then assume JSON unless otherwise specified\r\n                body = await decodeBody(response, headers.get('Accept'));\r\n        }\r\n\r\n        return {\r\n            statusCode,\r\n            headers: responseHeaders,\r\n            body,\r\n            response\r\n        };\r\n    }\r\n    async get<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('GET', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async post<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('POST', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async put<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('PUT', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async patch(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('PATCH', endpoint, data, options);\r\n    }\r\n    async delete(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('DELETE', endpoint, data, options);\r\n    }\r\n    /**\r\n     * authenticate with Rev\r\n     */\r\n    async connect() {\r\n\r\n        // Rarely the login call will fail on first attempt, therefore this code attempts to login\r\n        // multiple times\r\n        await retry(\r\n            () => this.session.login(),\r\n            // Do not re-attempt logins with invalid user/password or rate limiting - it can lock out the user\r\n            (err: RevError) => ![401, 429].includes(err.status));\r\n    }\r\n    /**\r\n     * end rev session\r\n     */\r\n    async disconnect() {\r\n        try {\r\n            await this.session.logoff();\r\n        } catch (error) {\r\n            this.log('warn', `Error in logoff, ignoring: ${error}`);\r\n        }\r\n    }\r\n    // this should get called every 15 minutes or so to extend the connection session\r\n    async extendSession() {\r\n        return this.session.extend();\r\n    }\r\n    /**\r\n     * Returns true/false based on if the session is currently valid\r\n     * @returns Promise<boolean>\r\n     */\r\n    async verifySession() {\r\n        return this.session.verify();\r\n    }\r\n    get isConnected() {\r\n        return !!this.session.token && !this.session.isExpired;\r\n    }\r\n    get token() {\r\n        return this.session.token;\r\n    }\r\n    get sessionExpires() {\r\n        return this.session.expires;\r\n    }\r\n    get sessionState() {\r\n        return this.session.toJSON();\r\n    }\r\n    set sessionState(state: Rev.IRevSessionState) {\r\n        this.session.token = `${state.token}`;\r\n        this.session.expires = new Date(state.expiration);\r\n        for (let key of ['apiKey', 'refreshToken', 'userId'] as (keyof Rev.IRevSessionState)[]) {\r\n            if (key in state) {\r\n                (this.session as any)[key] = `${state[key] || ''}`;\r\n            }\r\n        }\r\n    }\r\n    log(severity: Rev.LogSeverity, ...args: any[]) {\r\n        if (!this.logEnabled) {\r\n            return;\r\n        }\r\n        const ts = (new Date()).toJSON().replace('T', ' ').slice(0, -5);\r\n        console.debug(`${ts} REV-CLIENT [${severity}]`, ...args);\r\n    }\r\n}\r\n"],"mappings":"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","names":["roles","customFields","field","i","hmacSign","query","options","query","options","ONE_MINUTE"]}